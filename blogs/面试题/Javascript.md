# js 面试题

### 类型
---
* Infinity代表什么数据？
```
全局属性 Infinity 是一个数值，表示无穷大。与 Number.POSITIVE_INFINITY 的数值相同

Number.MAX_SAFE_INTEGER：表示在 JavaScript 中最大的安全整数（253 – 1）
Number.MAX_VALUE：表示在 JavaScript 里所能表示的最大数值
Number.POSITIVE_INFINITY：表示正无穷大
```
* 如何把10.36四舍五入为最接近的整数？
```
方法一：Math.floor()
方法二：Number.toFixed()
```
* 把对象转换到字符串类型是如何转换的？
```
方法一：使用JSON.stringify()
```
* 把对象转换到数字类型是如何转换的？
```
1.先调用对象的valueOf方法
2.判断该方法的返回值是否为基础数据类型（Number，String，Boolean，Undefined，Null）
3.若返回值为基础数据类型，则转换规则按照相应数据类型的转换规则对其进行转换
4.若返回值不为基础数据类型，则在该返回值的基础上继续调用toString方法
5.判断toString的返回值是否为基础数据类型
6.判断是否为基础数据类型，若是基础数据类型则进行操作3
7.若仍旧不为基础数据类型则报错
```
* 请你解释一个为什么10.toFixed(10)会报错？
```
之所以会报错时因为这里的.发生了歧义，既可以理解成浮点数的小数点，又可以理解为对方法的调用。因为数字后面紧跟着一个.，解释器就默认为浮点数，所以会报错。
```
* 如何避免JS浮点运算的精度问题（例：0.1+0.7=0.7999999999999999）
* js如何解决数字精度丢失的问题？
```
首先考虑的是如何解决浮点数运算的精度问题，有 3 种思路：

考虑到每次浮点数运算的偏差非常小(其实不然)，可以对结果进行指定精度的四舍五入，比如可以parseFloat(result.toFixed(12));
将浮点数转为整数运算，再对结果做除法。比如0.1 + 0.2，可以转化为(1*2)/3。
把浮点数转化为字符串，模拟实际运算的过程。
先来看第一种方案，在大多数情况下，它可以得到正确结果，但是对一些极端情况，toFixed 到 12 是不够的，比如：

210000 * 10000  * 1000 * 8.2    // 17219999999999.998
parseFloat(17219999999999.998.toFixed(12));    // 17219999999999.998，而正确结果为 17220000000000
上面的情况，如果想让结果正确，需要 toFixed(2)，这显然是不可接受的。

再看第二种方案，比如 number-precision 这个库就是使用的这种方案，但是这也是有问题的，比如：

// 这两个浮点数，转化为整数之后，相乘的结果已经超过了 MAX_SAFE_INTEGER
123456.789 * 123456.789     // 转化为 (123456789 * 123456789)/1000000，结果是 15241578750.19052

所以，最终考虑使用第三种方案，目前已经有了很多较为成熟的库，比如 bignumber.js，decimal.js，以及big.js等。我们可以根据自己的需求来选择对应的工具。并且，这些库不仅解决了浮点数的运算精度问题，还支持了大数运算，并且修复了原生toFixed结果不准确的问题。
```
* 举例子说说你对js隐式类型转换的理解
```
类型的隐式转换发生在==或者+等运算符中。
隐式转换一般会先调用原型上的valueOf方法，如果返回结果仍然不能比较就会再调用toString方法，
```

* 请解释下NaN === NaN的结果
```
false
全局属性 NaN 是一个表示非数字的值
要判断一个值是否为 NaN，可以使用 Number.isNaN() 或 isNaN() 来最清楚地确定一个值是否为 NaN ，因为 NaN 是唯一与自身不相等的值，所以你可以执行类似 x !== x 这样的自我比较
```
* 请介绍下js的数据类型
```
JavaScript 是一种有着动态类型的动态语言。JavaScript 中的变量与任何特定值类型没有任何关联，并且任何变量都可以分配（重新分配）所有类型的值
```
* 举例说明什么是短路求值？
```
短路求值 （Short-circuit evaluation; minimal evaluation; McCarthy evaluation; 又称 最小化求值 ） ，是一种 逻辑运算符 的求值策略。 只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值。 例如，当AND的第一个运算数的值为false时，其结果必定为false；当OR的第一个运算数为true时，最后结果必定为true，在这种情况下，就不需要知道第二个运算数的具体值
```
* 表达式和语句有什么区别？如何把语句转换为表达式？
```
表达式是可以被求值的代码，而语句是一段可执行代码。因为表达式可被求值，所以它可写在赋值语句等号的右侧。而语句不一定有值，所以像import、for和break等语句就不能被用于赋值。Python的语句分为两大类：简单和复合语句。简单语句是指一逻辑行的代码。例如表达式语句、赋值语句和return语句等。复合语句是指包含、影响或控制一组语句的代码。例如if、try和class语句等。表达式本身可以作为表达式语句，也能作为赋值语句的右值或if语句的条件等，所以表达式可以作为语句的组成部分，但不是必须成分（例如continue语句）
```
* 你知道什么是三元表达式吗？“三元” 表示什么意思？使用三元表达式应该注意些什么问题？
```
条件（三元）运算符是 JavaScript 唯一使用三个操作数的运算符：一个条件后跟一个问号（?），如果条件为真值，则执行冒号（:）前的表达式；若条件为假值，则执行最后的表达式
```
* 有些js库习惯在代码开头处添加分号有什么作用呢？除了分号还可以换成别的吗？
```
js 文件结束 处是 没有 分号的。若几个 js 连在一起时，2个 js 连接处 会发生语法上的混淆。
开头加 ; 用于分隔， 可以避免多文件 压缩 在一起时 引起的 错误。
分号和分号放在一起也没问题，相当于 “空语句”。
```
* JavaScript有几种类型值？能否画出它们的内存图？
```
栈内存：原始数据类型（undefined、null、string、number、boolean）
堆内存：引用数据类型（对象、数组、函数）

区别：

声明变量时不同的内存分配：
原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。
引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。

不同的内存分配机制也带来了不同的访问机制　　
在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，即按引用访问。 
而原始类型的值则是可以直接访问到的。　　

复制变量时的不同　　 
原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。 
引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针　 

参数传递的不同（把实参复制给形参的过程）。首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。 
原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。
引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。 
```
* 说说你对数据类型转换的理解是什么？类型转换的方法有哪些？
```
不同类型无法比较或者运算，需要将他们转换成同类型的运算或者比较。先调用valueOf方法，如果还是无法比较调用toString方法

显式转换：Boolean，Number，String， parseInt,parseFloat, toString, JSON.stringify
隐式转换：==、+、~等
```
* 举例子说明javascript的变量声明提升和函数声明提升
```
var getName = function(){
  console.log(4)
}

function getName() {
  console.log(5)
}

getName() // 4 函数声明优先级高于var声明,  故 4 覆盖了 5
```
* 写出js各类型转化为Boolean的值分别是什么？及转化的规则是什么？
```
Number数值型的数据，使用Boolean()函数进行转换时，除了数字0和特殊数字NaN转换后是false，其他的数字都是true，包括无穷表达值Infinity；
String字符串，除了空串转换后是false，其余都是true；
null和undefined转换后都是false；
对象转换后都是是true；

总结
如果省略该参数或参数值为 0、-0、null、false、NaN、undefined，或空字符串（""），则该对象具有的初始值为 false。所有其他值，包括任何对象，空数组（[]）或字符串 "false"，都会创建一个初始值为 true 的对象
```
* 代码中如果遇到未定义的变量，会抛出异常吗？程序还会不会继续往下走？
```
js在遇到未定义的变量时，会出现uncaught referenceerror：is not defined，根本原因是，js是单线程的。这时js会停止解析后面的代码，跳出代码块，之前的代码不受影响，之后的代码块也不会受到影响。报错阻塞后面的代码执行，程序不会继续往下走。
```
* js可以用中文作为变量命名吗？为什么？
```
可以使用中文名作为变量，可能导致的问题有
1. 文档的编码格式不是utf-8可能导致乱码。一般默认编码模式为 utf-8，但有一些编辑器并不会设定默认值，这时候，你就会发现，页面里的中文变成非语义化的字符（俗称乱码）了。或者某些人的浏览器默认编码并不是 utf-8，而是例如 gb2312、gbk 之类的编码，那么也可能产生乱码

2. 命名不当，懂中文的和不懂中文的都看不懂意思
3. 如果默许可以使用中文，那么这个口子一旦打开，代码里到处是各种中文名字、奇怪的缩写、拼音英文混合，造成混乱局面。
```
* 说下js的parseInt()和Number()有什么区别？
```
parseInt:parseInt(string, radix) 解析一个字符串并返回指定基数的十进制整数，radix 是 2-36 之间的整数，表示被解析字符串的基数
```
* 请问typeof typeof 168的结果是什么？
```
'string'
typeof 168 // 'number'
typeof 'number' // 'string'
```
* 请说说new String("A")和String("A")分别返回的结果，请解释为什么？
```
new String('A')返回一个对象，
String('A')返回一个字符串，原始类型
```
* 0.1 + 0.2、0.1 + 0.3和0.1 * 0.2分别等于多少？并解释下为什么？
```
0.1转化成二进制是一个无限循环小数，但是计算机只能用有限的位数来存一个数，所以最终，计算机存的数是一个近似于 0.1 的小数。转换的过程中会损失精度
所以，0.1+0.2是近似值相加
```
* 说说instanceof和typeof的实现原理并自己模拟实现一个instanceof
```
typeof 运算符返回一个字符串（表示基本数据类型或者对象类型），表示操作数的类型
Undefined -> "undefined"
Null -> "null"
Boolean -> "boolean"
Number -> "number"
BigInt -> "bigInt"
String -> "string"
Symbol -> "symbol"
Function -> "function"
其他任何对象 -> "object"

instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
```
* js中=、==、===三个的区别是什么？并说明它们各自的工作过程
```
= 表示赋值
== 表示相等，它会比较不同类型的操作数，并尝试强制类型转换
1. 如果操作数具有相同的类型，则按如下方式进行比较：
  对象（Object）：仅当两个操作数引用同一个对象时返回 true。
  字符串（String）：只有当两个操作数具有相同的字符且顺序相同时才返回 true。
  数值（Number）：如果两个操作数的值相同，则返回 true。+0 和 -0 被视为相同的值。如果任何一个操作数是 NaN，返回 false；所以，NaN 永远不等于 NaN。
  布尔值（Boolean）：仅当操作数都为 true 或都为 false 时返回 true。
  大整形（BigInt）：仅当两个操作数值相同时返回 true。
  符号（Symbol）：仅当两个操作数引用相同的符号时返回 true。
2. 如果其中一个操作数为 null 或 undefined，另一个操作数也必须为 null 或 undefined 以返回 true。否则返回 false。
3. 如果其中一个操作数是对象，另一个是基本类型，按此顺序使用对象的 @@toPrimitive()（以 "default" 作为提示），valueOf() 和 toString() 方法将对象转换为基本类型。（这个基本类型转换与相加中使用的转换相同。）
4. 在这一步，两个操作数都被转换为基本类型（String、Number、Boolean、Symbol 和 BigInt 中的一个）。其余的转换是逐个进行的。
  如果是相同的类型，使用步骤 1 进行比较。
  如果其中一个操作数是 Symbol 而另一个不是，返回 false。
  如果其中一个操作数是布尔型而另一个不是，则将布尔型转换为数字：true 转换为 1，false 转换为 0。然后再次松散地比较两个操作数。
  Number to String：使用与 Number() 构造函数相同的算法将字符串转换为数字。转换失败将导致 NaN，这将保证相等是 false。
  Number to BigInt：按数值进行比较。如果数值为 ±∞ 或 NaN，返回 false。
  String to BigInt：使用与 BigInt() 构造函数相同的算法将字符串转换为 BigInt。如果转换失败，返回 false。

=== 表示严格相等，严格相等运算符总是认为不同类型的操作数是不同的
如果操作数的类型不同，则返回 false。
如果两个操作数都是对象，只有当它们指向同一个对象时才返回 true。
如果两个操作数都为 null，或者两个操作数都为 undefined，返回 true。
如果两个操作数有任意一个为 NaN，返回 false。
否则，比较两个操作数的值：
数字类型必须拥有相同的数值。+0 和 -0 会被认为是相同的值。
字符串类型必须拥有相同顺序的相同字符。
布尔运算符必须同时为 true 或同时为 false


严格相等运算符总是认为不同类型的操作数是不同的，相等会尝试类型转换
```
* 解释下为什么{} + [] === 0为true？而[]+{}===0为false
```
先说 [] + {} 。
一个数组加一个对象。 加法会进行隐式类型转换，规则是调用其 valueOf() 或 toString() 以取得一个非对象的值（primitive value）。如果两个值中的任何一个是字符串，则进行字符串串接，否则进行数字加法。
 [] 和 {} 的 valueOf() 都返回对象自身，所以都会调用 toString()，最后的结果是字符串串接。[].toString() 返回空字符串，({}).toString() 返回“[object Object]”。最后的结果就是“[object Object]”。

 然后说 {} + [] 。看上去应该和上面一样。但是 {} 除了表示一个对象之外，也可以表示一个空的 block。在 [] + {} 中，[] 被解析为数组，因此后续的 + 被解析为加法运算符，而 {} 就解析为对象。但在 {} + [] 中，{} 被解析为空的 block，随后的 + 被解析为正号运算符。即实际上成了： 
 { // empty block }
 +[]
即对一个空数组执行正号运算，实际上就是把数组转型为数字。首先调用 [].valueOf() 。返回数组自身，不是primitive value，因此继续调用 [].toString() ，返回空字符串。空字符串转型为数字，返回0，即最后的结果。
```
* 举例说明+运算符的运行机制
```
一元加（+）运算符在其操作数之前并计算其操作数，但会尝试将其转换为数字
```
* 请描述下null和undefined的区别是什么？这两者分别运用在什么场景？
```
null表示空；undefined表示不存在

null运用场景
1. 变量初始化
2. 原型链的终点

undefined运用场景
1. 函数没有返回值，默认返回undefined
2. 变量已声明未赋值
3. 调用函数时，该提供的参数未提供
```
* 你知道1和Number(1)的区别是什么吗？
```
在不使用new关键字作建构对象实例时，使用像Number(123)这样的语法，这是一种从其他资料类型要转到数字类型的函数调用语法。调用后仍然是原始资料类型，并不会产生包装对象实例
```

* 请解释下NaN表示什么呢？typeof NaN结果是什么？
```
全局属性 NaN 是一个表示非数字的值
typeof NaN // 'number'
```
* 请分析020-088=?的过程及结果
```
020会被识别未8进制，即16，088会被识别为10进制即88，所以最后结果为-72
```

* 判断[].__proto__.__proto__ === {}.__proto__结果并解释为什么?
```
true
通过原型链，查找到的都是Object构造函数原型对象
```
* js中的undefined和 ReferenceError: xxx is not defined 有什么区别？
```
undefined是javascript语言中定义的五个原始类中的一个，换句话说，undefined并不是程序报错，而是程序允许的一个值。
not defined是javascript在运行我们的javascript代码时，遇到没有定义就用来运算的变量时爆出来的错误。

在许多的javascript教程中都介绍有javascript变量即使不定义也可以直接拿来使用，但是请注意，这个使用是指可以被赋值，但是不可以被运算。例如
var temp;
temp2 = 123;
alert(temp2);
temp3 = temp4+1; //报错，temp4 not defined
alert(temp3) 
```
* Math.min() < Math.max() 返回结果是什么？为什么？
```
Math.min() // Infinity
Math.max() // -Infinity
引用mdn：Math.min() 函数返回作为输入参数的数字中最小的一个，如果没有参数，则返回 Infinity；Math.max() 函数返回作为输入参数的最大数字，如果没有参数，则返回 -Infinity
```

* js中的数字在电脑内存储为多少Byte？
```
js内部，所有数字都是以64位浮点数形式存储的，整数也是。64bit = 8byte
```

* 说一说symbol
```
symbol的功能类似于一种标识唯一性的 ID
1. 通过调用 Symbol()函数来创建一个 Symbol 实例,每个 Symbol 实例都是唯一的。因此，当你比较两个 Symbol 实例的时候，将总会返回 false
2. 使用 typeof 去检查它的类型的时候，它会返回一个属于自己的类型 symbol，而不是什么 string、object 之类的

引用场景
1. 使用 Symbol 来作为对象属性名(key)，Symbol 类型的 key 是不能通过Object.keys()或者for...in来枚举的，它未被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用 Symbol 来定义
2. 使用 Symbol 代替常量，我们经常定义一组常量来代表一种业务逻辑下的几个不同类型，我们通常希望这几个常量之间是唯一的关系，为了保证这一点，我们需要为常量赋一个唯一的值
3. 使用 Symbol 定义类的私有属性/方法，我们知道在 JavaScript 中，是没有如 Java 等面向对象语言的访问控制关键字 private 的，类上所有定义的属性或方法都是可公开访问的。因此这对我们进行 API 的设计时造成了一些困扰

特别注意
1. Symbol 函数前不能使用 new 命令，否则会报错。
2. Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。
3. Symbol 作为属性名，该属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。
4. Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
5. Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。
6. Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。
```


### 方案设计
* 实现一个系统，统计前端页面性能、页面 JS 报错、用户操作行为、PV/UV、用户设备等消息，并进行必要的监控报警。方案如何设计，用什么技术点，什么样的系统架构，难点会在哪里？
```
一、需求背景
1.1 为什么要做
更快的发现问题
做产品决策依据
提升前端开发的技术深度和广度
为业务扩展提供更多可能性
为了实现收集功能，我们需要一个前端监控平台，它能够收集数据、处理数据、存储数据、查询数据。其实就有很多现成的平台或者开源项目我们可以直接使用。

1.2 行内通用方案
前端技术发展至今，相信大家已经对前端监控的这件事情非常熟悉，或多或少都会在我们的项目中用上它。比如搭建使用开源项目 sentry、付费平台阿里的 ARMS、甚至小程序配套的前端监控服务。

sentry，sentry 主要提供的功能是收集错误。支持大多流行语言的客户端和服务端，不支持小程序，但是目前有大公司根据 sentry 的上报数据结构，自己实现了小程序 SDK 并开源，目前关注度和流行度都偏低。除开错误，它的其它类型的前端监控能力相对来说很弱。
阿里 ARMS，ARMS 提供的功能与支持的客户端比较齐全，小程序也支持。只是需要付费。总体来说提供的功能还是比较全面、符合国内的环境。
小程序自带监控 微信小程序不断的在完善内部的监控，各方面的功能也慢慢丰富了起来，但是只能支持小程序本身。
在使用这些开源或者平台前端监控服务的时候，始终有一些不足。比如：

系统分散
很难满足增加一些自定义数据和查询的需求
特性一直不更新、Bug 解决周期长
二次开发难度大
1.3 定制化
如果完全从 0 到 1 来打造一套前端监控系统，成本也是很高的。甚至在早期，都可能没人愿意用，系统是否能立项或者持续发展下去也是一个问题。于是从一些开源项目中去寻找，去找一个方便改造也有一定功能模块的项目。可以基于它的代码，进行长期的改造和迭代。慢慢的改造成为一个更适合公司内部环境的一个前端监控系统。

二、系统架构
2.1 基本构成
客户端 SDK：web
服务端 node + EggJs
数据库 Redis Mongo+mongooseJs(orm)
管理台 Vue + ElementUI
为了实现前端监控，第一要素是要收集客户端数据，为了方便客户端集成监控系统、我们需要首先开发封装一个统一的 SDK、去帮助我们收集数据。

SDK 收集了数据，我们还需要通过服务端接口来接收，在服务端，使用 node+EggJs，node 适合 i/o 密集型场景，符合前端技术栈。eggjs 简单易用、文档友好，大部分使用 node 的前端程序员都应该能很快上手。

服务端收集到数据并进行一些处理之后，我们需要存储到我们的数据库之中。在数据库方面，使用 mongo 做持久化存储，mongo 文档模型数据库，数据扩展方便，类 json 结构方便和 node 配合使用，天生适合日志系统。使用 redis 做数据缓存，redis 简单易用的高性能 key-value 数据库，市场上占据主流，被大部分人都熟知。

最后，还需要一个管理台，做数据查询与管理。管理台使用 Vue+ElementUI，简单快速。

客户端 SDK 收集数据上报，node 服务端获取到数据后，先存在 redis 中，node 服务会根据消费能力去拉取 redis 数据处理分析后存储到 mongo 之中，最后我们通过管理后台展示处理好的应用数据。

2.2 技术的可能的一些难点
可能整个系统比较复杂的就是如何高效合理的进行监控数据上传。除了异常报错信息本身，还需要记录用户操作日志，如果任何日志都立即上报，这无异于自造的 DDOS 攻击。那就需要考虑前端日志的存储，日志如何上传，上传前如何整理日志等问题。

对于日志的处理上报有这样的处理方案

前端存储日志
我们并不单单采集异常本身日志，而且还会采集与异常相关的用户行为日志。单纯一条异常日志并不能帮助我们快速定位问题根源，找到解决方案。但如果要收集用户的行为日志，又要采取一定的技巧，而不能用户每一个操作后，就立即将该行为日志传到服务器，对于具有大量用户同时在线的应用，如果用户一操作就立即上传日志，无异于对日志服务器进行 DDOS 攻击。因此，我们先将这些日志存储在用户客户端本地，达到一定条件之后，再同时打包上传一组日志。

那么，如何进行前端日志存储呢？我们不可能直接将这些日志用一个变量保存起来，这样会挤爆内存，而且一旦用户进行刷新操作，这些日志就丢失了，因此，我们自然而然想到前端数据持久化方案。

目前，可用的持久化方案可选项也比较多了，主要有：Cookie、localStorage、sessionStorage、IndexedDB、webSQL 、FileSystem 等等。那么该如何选择呢？我们通过一个表来进行对比：

cookie：使用字符串存储，容量4kb，同步。
localStorage：使用key-value的字符串形式存储，容量5M，同步，通过key进行检索，读快写慢
sessionStorage:使用key-value的字符串形式存储，容量5M，同步，通过key进行检索
indexedDB:使用NoSQL的object形式存储，容量500M，异步，通过key或者index进行检索，读慢写快
webSQL：使用SQL的形式存储，容量60M，异步，通过field进行检索。
	
综合之后，IndexedDB 是最好的选择，它具有容量大、异步的优势，异步的特性保证它不会对界面的渲染产生阻塞。而且 IndexedDB 是分库的，每个库又分 store，还能按照索引进行查询，具有完整的数据库管理思维，比 localStorage 更适合做结构化数据管理。但是它有一个缺点，就是 api 非常复杂，不像 localStorage 那么简单直接。针对这一点，我们可以使用 hello-indexeddb 这个工具，它用 Promise 对复杂 api 进行来封装，简化操作，使 IndexedDB 的使用也能做到 localStorage 一样便捷。另外，IndexedDB 是被广泛支持的 HTML5 标准，兼容大部分浏览器，因此不用担心它的发展前景。

日志上报
按照上报的频率（重要紧急度）可将上报分为四类

即时上报
收集到日志后，立即触发上报函数。仅用于 A 类异常。而且由于受到网络不确定因素影响，A 类日志上报需要有一个确认机制，只有确认服务端已经成功接收到该上报信息之后，才算完成。否则需要有一个循环机制，确保上报成功。

批量上报
将收集到的日志存储在本地，当收集到一定数量之后再打包一次性上报，或者按照一定的频率（时间间隔）打包上传。这相当于把多次合并为一次上报，以降低对服务器的压力。

区块上报
将一次异常的场景打包为一个区块后进行上报。它和批量上报不同，批量上报保证了日志的完整性，全面性，但会有无用信息。而区块上报则是针对异常本身的，确保单个异常相关的日志被全部上报。

用户主动提交
在界面上提供一个按钮，用户主动反馈 bug。这有利于加强与用户的互动。

或者当异常发生时，虽然对用户没有任何影响，但是应用监控到了，弹出一个提示框，让用户选择是否愿意上传日志。这种方案适合涉及用户隐私数据时。

即时上报：紧急重要的容量小的情况下，立即一次性全部上报
批量上报：不紧急的容量适中情况下，定时性的一次xxx条的上报
区块上报：不紧急但是很重要情况下，稍延时的单次上报相关条目
用户反馈：不紧急的情况下，延时一次一条的上报

即时上报虽然叫即时，但是其实也是通过类似队列的循环任务去完成的，它主要是尽快把一些重要的异常提交给监控系统，好让运维人员发现问题，因此，它对应的紧急程度比较高。

批量上报和区块上报的区别：批量上报是一次上报一定条数，比如每 2 分钟上报 1000 条，直到上报完成。而区块上报是在异常发生之后，马上收集和异常相关的所有日志，查询出哪些日志已经由批量上报上报过了，剔除掉，把其他相关日志上传，和异常相关的这些日志相对而言更重要一些，它们可以帮助尽快复原异常现场，找出发生异常的根源。

用户提交的反馈信息，则可以慢悠悠上报上去。

```
* 如果让你来实现一个前端监控系统，应该考虑什么？如何去实现
```
一、为什么要做前端监控
更快的发现问题
做产品决策依据
提升前端开发的技术深度和广度
为业务扩展提供更多可能性
二、前端数据分类
前端的数据其实有很多，从大众普遍关注的 PV、UV、广告点击量，到客户端的网络环境、登陆状态，再到浏览器、操作系统信息，最后到页面性能、JS 异常，这些数据都可以在前端收集到。

2.1 访问相关的数据
PV/UV:最基础的 PV(页面访问量)、UV(独立访问用户数据量)
页面来源：页面的 referer,可以定位页面的入口
操作系统：了解用户的 OS 情况，帮助分析用户群体的特征，特别是移动端、iOS 和 Android 的分布就更有意义了
浏览器：可以统计到各种浏览器的占比，对于是否继续兼容 IE6、新技术(HTML5、CSS3 等)的运用等调研提供参考价值
分辨率：对页面设计提供参考，特别是响应式设计
登录率：登陆用户具有更高的分析价值，引导用户登陆是非常重要的
地域分布：访问用户在地理位置上的分布，可以针对不同地域做运营、活动等
网络类型：wifi/3G/2G，为产品是否需要适配不同网络环境做决策
访问时段：掌握用户访问时间的分布，引导消峰填谷、节省带宽
停留时长：判断页面内容是否具有吸引力，对于需要长时间阅读的页面比较有意义
到达深度：和停留时长类似，例如百度百科，用户浏览时的页面到达深度直接反映词条的质量
2.2 性能相关的数据
白屏时间：用户从打开页面开始到页面开始有东西呈现为止，这过程中占用的时间就是白屏时间
首屏时间：用户浏览器首屏内所有内容都呈现出来所花费的时间
用户可操作时间：用户可以进行正常的点击、输入等操作
页面总下载时间：页面所有资源都加载完成并呈现出来所花的时间，即页面 onload 的时间
自定义的时间点：对于开发人员来说，完全可以自定义一些时间点，例如：某个组件 init 完成的时间、某个重要模块加载的时间等等
2.3 点击相关的数据
页面总点击量
人均点击量：对于导航类的网页，这项指标是非常重要的
流出 url：同样，导航类的网页，直接了解网页导流的去向
点击时间：用户的所有点击行为，在时间上的分布，反映了用户点击操作的习惯
首次点击时间：同上，但是只统计用户的第一次点击，如果该时间偏大，是否就表明页面很卡导致用户长时间不能点击呢？
点击热力图：根据用户点击的位置，我们可以画出整个页面的点击热力图，可以很直观的了解到页面的热点区域
2.4 异常相关的数据
这里的异常是指 JS 的异常，用户的浏览器上报 JS 的 bug，这会极大地降低用户体验

异常的提示信息：这是识别一个异常的最重要依据，如：e.src 为空或不是对象
JS 文件名
异常所在行
发生异常的浏览器
堆栈信息：必要的时候需要函数调用的堆栈信息，但是注意堆栈信息可能会比较大，需要截取
2.5 其它数据
除了上面提到的 4 类基本的数据统计需求，我们当然还可以根据实际情况来定义一些其他的统计需求，如用户浏览器对 canvas 的支持程度， 再比如比较特殊的-用户进行轮播图翻页的次数，这些数据统计需求都是前端能够满足的，每一项统计的结果都体现了前端数据的价值

三、性能指标
FP(First Paint)：首次绘制时间，包括了任何用户自定义的背景绘制，它是首先将像素绘制到屏幕的时刻。
FCP(First Content Paint)：首次内容绘制。是浏览器将第一个 DOM 渲染到屏幕的时间，可能是文本、图像、SVG 等。这其实就是白屏时间
FMP(First Meaningful Paint)：首次有意义绘制。页面有意义的内容渲染的时间
LCP(Largest Contentful Paint)。最大内容渲染。代表在 viewport 中最大的页面元素加载的时间。
DCL(DomContentLoaded)：DOM 加载完成。当 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发。无需等待样式表，图像和子框架的完成加载。
L(onload)：当依赖的资源全部加载完毕之后才会触发。
TTI(Time to Interactive)：可交互时间。用于标记应用已进行视觉渲染并能可靠响应用户输入的时间点。
FID(First Input Delay)：首次输入延迟。用户首次和页面交互(单击链接、点击按钮等)到页面响应交互的时间。
四、前端监控目标(监控分类)
4.1 稳定性(stability)
JS 错误，JS 执行错误或者 Promise 异常
资源异常，script、link 等资源加载异常
接口错误,ajax 或 fetch 请求接口异常
白屏，页面空白
4.2 用户体验(experience)
加载时间，各个阶段的加载时间
TTFB(Time To First Byte 首字节时间)。是指浏览器发起第一个请求到数据返回第一个字节所消耗的时间，这个时间包含了网络请求时间、后端处理时间。
FP(First Paint 首次绘制)。首次绘制包括了任何用户自定义的背景绘制，它是将第一个像素点绘制到屏幕的时间。
FCP(First Content Paint 首次内容绘制)。首次内容绘制是浏览器将第一个 DOM 渲染到屏幕的时间，可以是任何文本、图像、SVG 等的时间。
FMP(First Meaningful Paint 首次有意义绘制)。 首次有意义绘制是页面可用性的量度标准。
FID(First Input Delay 首次输入延迟)。用户首次和页面交互到页面响应交互的时间。
卡顿。 超过 50ms 的任务。
4.3 业务
PV：page view 即页面浏览量或点击量
UV：指访问某个站点的不同 IP 地址的人数。
页面停留时间：用户在每一个页面的停留时间。
五、前端监控流程
数据埋点
数据上报
分析和计算，将采集到的数据进行加工总结
可视化展示，将数据按照各种维度进行展示
监控报警，发现问题后按一定的条件触发报警
六、常见的埋点方案
6.1 代码埋点
代码埋点，就是以嵌入代码的形式进行埋点，比如要监控用户的点击事件，会选择在用户点击时插入一段代码，保存这个监听行为或者直接将监听行为 以某一种数据格式直接传递给服务器端。
优点是可以在任意时刻，精确的发送或保存所需要的数据信息。
缺点就是工作量大
6.2 可视化埋点
通过可视化交互的手段，代替代码埋点。
将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义 的增加埋点事件等等。最后输出的代码耦合了业务代码和埋点代码
可视化埋点其实是用系统来代替手工插入埋点代码。
6.3 无痕埋点
前端的任意一个事件都被绑定一个标识，所有的事件都被记录下来。
通过定期上传记录文件，配合文件解析，解析出来我们想要的数据，并生成可视化报告供专业人员分析
无痕埋点的优点是采集全量数据，不会出现漏埋和误埋等现象
缺点是给数据传输和服务器增加压力，也无法灵活定制数据结构
七、编写监控采集脚本
7.1 监控错误
错误分类
JS 错误
Promise 异常
资源异常
监听 error
7.2 数据结构设计
jsError
let info = {
  title: "前端监控系统", // 页面标题
  url: "http://localhost:8080", // 页面url
  timestamp: "1212121212121212", // 访问时间戳
  userAgent: "chrome", // 用户浏览器类型
  kind: "stability", // 大类
  type: "error", // 小类
  errorType: "jsError", // 错误类型
  message: "uncaught TypeError:blablabla", // 错误详情
  filename: "http://localhost:8080/", // 访问的文件名
  position: "0:0", // 行列信息
  stack: "btn Click (http://localhost:8080)", // 堆栈信息
  selector: "HTML BODY #container .content INPUT", // 选择器
};
接口异常数据结构设置
let info = {
  title: "前端监控系统", // 页面标题
  url: "http://localhost:8080", // 页面url
  timestamp: "1212121212121212", // 访问时间戳
  userAgent: "chrome", // 用户浏览器类型
  kind: "stability", // 大类
  type: "xhr", // 小类
  eventType: "load", // 事件类型
  pathname: "/success",
  status: "200-0k",
  duration: "5", // 持续时间
  response: "hahah", // 响应内容
  params: "参数", // 参数
};
白屏 screen 返回当前 window 的 screen 对象，返回当前渲染窗口中和屏幕有关的属性
innerWidth 只读的 window 属性。innerWidth 返回以像素为单位的窗口的内部宽度
innerHeight 窗口的内部高度(布局视口)的高度
layout_viewport
elementsFromPoint 方法可以获取到当前视口内指定坐标处，由里到外排列的所有元素。
let info = {
  title: "前端监控系统",
  url: "http://localhost:8080/",
  timestamp: "1239404040404044",
  userAgent: "chorme",
  kind: "stability",
  type: "blank",
  emptyPoints: "0", // 空白点
  screen: "2049 * 1152", // 分辨率
  viewPoint: "2048 * 994", // 视口
  selector: "HTML BODY #container", // 选择器
};
整体大致可以分四个阶段：信息采集、存储、分析、监控。

采集阶段：收集异常日志，先在本地做一定的处理，采取一定的方案上报到服务器。

存储阶段：后端接收前端上报的异常日志，经过一定处理，按照一定的存储方案存储。

分析阶段：分为机器自动分析和人工分析。机器自动分析，通过预设的条件和算法，对存储的日志信息进行统计和筛选，发现问题，触发报警。人工分析，通过提供一个可视化的数据面板，让系统用户可以看到具体的日志数据，根据信息，发现异常问题根源。

报警阶段：分为告警和预警。告警按照一定的级别自动报警，通过设定的渠道，按照一定的触发规则进行。预警则在异常发生前，提前预判，给出警告。

性能监控： 使用 Resource Timing API 和 Performance Timing API，可以计算许多重要的指标，比如页面性能统计的起始点时间、首屏时间等。

异常监控： 前端捕获异常分为全局捕获和局部捕获。局部捕获作为补充，对某些特殊情况进行捕获，但分散，不利于管理。所以，我会选择全局捕获的方式，即通过全局的接口，将捕获代码集中写在一个地方。具体在实现项目中，我应该会采用 badjs-report，它重写了 window.onerror 进行上报异常，无需编写任何捕获错误的代码。

前端埋点： 埋点的方案有手动埋点，即在需要监控的地方插入监控逻辑，但是工作量可能会很大；还有无埋点，前端自动采集全部事件，上报埋点数据，但是缺点是服务器压力会很大。我可能倾向于采用声明式埋点，将埋点代码和具体的业务逻辑解耦，只用关心需要埋点的控件，并且为这些控件声明需要的埋点数据即可，主要是为了降低埋点的成本吧。在 dom 元素上增添埋点信息，比如

// key表示埋点的唯一标识；act表示埋点方式
<button data-stat="{key:'buttonKey', act: 'click'}">埋点</button>
监控告警： 这里我认为最便捷、高效的方式，就是接入内部的告警组了吧，尤其是在阿里，似乎什么轮子都有，那可能需要考虑就是触发告警的阈值和时机了。

性能：使用 Performance API，可以得到许多重要的指标，如页面性能统计的起始点时间、首屏时间等

报错：使用 onerror 和 onunhandledrejection，甚至是 try catch

操作行为：对事件触发函数做 patch，或者添加特定的事件监听

PV/UV：利用浏览器存储方法或 Cookie、IP 等储存相应用户信息，随请求发送

设备信息：获取 navigator.userAgent

PV、UV 属于增长数字类型，可以用 Redis 等记录，如果有需要，定时入库。其他属于大量文字信息，可以用成熟的消息队列来消费。因为有大量写，所以可以考虑做读写分离。

技术难点：

可能整个系统比较复杂的就是如何高效合理的进行监控数据上传。除了异常报错信息本身，还需要记录用户操作日志，如果任何日志都立即上报，这无异于自造的 DDOS 攻击。那就需要考虑前端日志的存储，日志如何上传，上传前如何整理日志等问题。

前端在收集的过程中可能会影响用户体验。

后端对于收到的日志要使用合适的工具进行收集，数据量大时选择如何取舍。

可能会采取的方案

indexDB 存储日志，因为容量大、异步！不用考虑阻塞页面问题。
在一个 webworker 中对日志进行整理，比如对每一条日志打上标签，进行分类等操作。
上报日志也在 webworker 中进行，可以按照重要紧急度区分，判断是否延时或者立即上报。
```
* 客户端与服务端时间为什么会不对称？不对称将会出现哪些问题？
* 前端如何保持与服务器时间同步（如何解决客户端与服务端时间不对称的问题）？
```
方案一：初次请求数据，将服务器的时间拿过来，通过计时器计时
弊端：
第一：存在网络延迟问题，前端真正拿到这个时间数据的时候并不能保证它是服务器的当前时间，因为还存在一个响应时间在里面
第二：通过计时器计时，例如setTimeout、setInterval这种方法，同样存在误差。不同平台的误差不一样，会被机器的性能、内存占用等多方面因素影响，一分钟可能会误差几秒钟，这种误差值无法被接收的。另一种做法是通过轮询拿服务器时间，但不会这么做。

方案二：在常规的做法基础上，解决它所带来的弊端。
第一，怎么解决响应时间问题，performance记录发送请求和接收响应的时间再做差
第二，怎么缩小计时过程中的误差，保持客户端时间和服务端时间的一致，我们可以通过本地时间计算出服务器时间，在第一次请求回来的时候，计算出服务器和客户端时间差，后面都通过这个差值计算出服务器时间
弊端：
在定时获取本地时间的过程中，本地时间很有可能被修改

方案三：在以上的基础上，要检测出本地时间被修改的问题，我们要计算出计时的误差，可以把每次定时获取的本地时间通过变量记录下来，而我们已知定时获取的周期，这样就可以计算出本次的预期时间，有了预期值和实际值就能算出误差了。我们可以通过设置一个误差最大值，如果超出了就开始纠正，公式如下
if(实际误差值>最大误差常量){
  服务器时间 = 本地时间 + 网络延迟时间 + 实际误差值
}else{
  服务器时间 = 本地时间 + 网络延迟时间
}

```

* 如何计算动画的帧率（FPS）？
```
requestAnimationFrame
```
* 你认为es5的设计缺陷有哪些？
* 说一下你了解的 WebSocket 鉴权授权方案
* 说一下实现骨架屏的方案？具体思路?
* 如何设计状态树
* 移动端适配方案具体实现以及对比
* 说一下组件库设计遵循的一些原则？

### 优化
---
* 你理解的"use strict";是什么?使用它有什么优缺点？常见的在严格模式下的现象
```
"use strict"指代码在严格条件下执行。严格模式的意义让项目中代码可以在严格条件下执行，可以限制一些不良的编码习惯，把问题在编码阶段就可以暴露出来
优点：
1. 严格模式通过抛出错误来消除一些原有的静默错误
2. 有时候严格模式下的代码比非严格模式运行更快
3. 消除js一些不合理、不严谨之处，减少一些怪异行为
4. 消除一些不安全之处，保证代码运行安全
5. 提高编译效率，增加运行速度
6. 为未来的新版本做铺垫
缺点：
1. 缺失许多开发人员已经习惯的功能
2. 无法访问function.caller和function.arguments。
3. 以不同严格模式编写的脚本合并后可能导致问题。
现象：
1. 禁止this指向全局对象
2. 全局变量必须显式声明
3. 不能使用未声明的变量
4. 去除了with语句
5. 不能修改arguments，不能在函数内定义arguments变量，不能使用argument.caller和argument.callee
```
* 说说你对RAIL性能评估模型的了解
```
RAIL模型是Chrome团队于2020.6发布的一种以用户为中心的性能模型。 它提供了一种考虑性能的结构。该模型将用户体验分解为关键操作（例如，点击、滚动、加载），并帮助您为每个操作定义性能目标。RAIL 代表 Web 应用程序生命周期的四个不同方面：响应(R)、动画(A)、空闲时间(I)和加载(L)

Response : 在 50 毫秒内处理事件
目标：在 100 毫秒内完成由用户输入发起的转换，让用户感觉交互是即时的。
指导方针：
事件处理函数尽量保证在50ms内完成，考虑到idle task的情况，事件会排队，等待时间大概在50ms。适用于click，toggle，starting animations等，不适用于drag和scroll；
复杂的js计算尽可能放在后台，如web worker，避免对用户输入造成阻塞 ；
超过50ms的响应，一定要提供反馈，比如倒计时，进度百分比等

Animation：在 10 毫秒内生成一帧
目标：
产生每一帧的时间不要超过10ms，为了保证浏览器60帧，每一帧的时间在16ms左右，但浏览器需要用6ms来渲染每一帧。
旨在视觉上的平滑。用户对帧率变化感知很敏感
指导方针：
在一些高压点上，比如动画，不要去挑战cpu，尽可能地少做事，如：取offset，设置style等操作。尽可能地保证60帧的体验。

Idle：空闲。指利用好空闲时间
目标：最大化空闲时间，以增大50ms内响应用户输入的几率
指导方针：
用空闲时间来完成一些延后的工作（比如说埋点），如先加载页面可见的部分，然后利用空闲时间加载剩余部分，此处可以使用
在空闲时间内执行的任务尽量控制在50ms以内，如果更长的话，会影响input handle的pending时间
如果用户在空闲时间任务进行时进行交互，必须以此为最高优先级，并暂停空闲时间的任务

load： 传输内容到页面可交互的时间不超过5秒
如果页面加载比较慢，用户的交点可能会离开。加载很快的页面，用户平均停留时间会变长，跳出率会更低，也就有更高的广告查看率
目标：
优化加载速度，可以根据设备、网络等条件。目前，比较好的一个方式是，让你的页面在一个中配的3G网络手机上打开时间不超过5秒
对于第二次打开，尽量不超过2秒
指导方针：
在手机设备上测试加载性能，选用中配的3G网络（400kb/s，400ms RTT），可以使用 WebPageTest 来测试
要注意的是，即使用户的网络是4G，但因为丢包或者网络波动，可能会比预期的更慢
禁用渲染阻塞的资源，延后加载defer、async等
可以采用 lazy load、code-splitting等 其他优化手段，让第一次加载的资源更少
影响页面加载性能的因素：
网络速度和延迟
硬件（例如较慢的CPU）
缓存
二级/三级缓存中的差异
解析JavaScript
```
* 如何设计一个JS SDK？说说你的方法
```
SDK全称是“Software Development Kit”，直译就是软件开发工具集。比如 Java SDK（JDK），就是一个Java领域的软件包。基于它，开发人员就可以快速构建自己的Java应用。比较规范的SDK一般都会包含若干的API、开发工具集和说明文档。基于JS封装的SDK更多常见于UI组件库、统计分析、web服务接口封装、前端稳定性和性能监控等场景。

遵从的设计原则：
1. 最小可用性原则，即用最少的代码，如无必要勿增实体
2. 最少依赖原则，即最低限度的外部依赖，如无必要勿增依赖

SDK要求
1. 满足功能需求：SDK一般都是偏于面向某个领域，所以，同时在设计和实现的时候明确职责和边界很重要，同时还应该足够精简，专注领域内的业务。
2. 足够稳定：绝不能导致宿主应用崩溃，这是最基础也是最严格的要求；较好的性能，比如SDK体积应尽量小，运行速度尽量快；可测试，保障每一次变更；向后兼容，不轻易出现 Breakchange
3. 少依赖，易扩展：最小程度的第三方依赖，尽可能自行实现，确实无法避免则最小化引入；插件化，最大限度支持扩展；Hook机制，满足个性化诉求

怎么实现
1.明确职责，限定边界：例如要做一个面向前端h5领域的稳定性监控和性能监控的SDK，稳定性上要关注的点JS异常、资源加载异常、API请求的异常和白屏异常；在性能方面需要关注的点可以参考Rail模型，响应时间、动画帧率、空闲时间、白屏时间、可交互时间、首屏时间等。

2. 基础框架：确定SDK的引用形式，例如CDN和 NPM两种引入方式；确定SDK的版本管理机制，现有较成熟的版本管理机制当属 语义化版本号 ，表现形式为 {主版本}.{次版本}.{补丁版本}，简单易记好管理；确定SDK的基础接口，接口是SDK和用户沟通的桥梁，每一个接口对应着一个独立的SDK功能，并且有明确的输入和输出，遵从单一职责、简单清晰命名、参数校验和逻辑保护，例如jsSdk.reportJSError(error)、jsSdk.report(logData)等

3. 模块细分
SDK底层提供基础的能力，包括上面提到的内核、插件机制的实现、工具类库以及暴露给用户的基础API

所有模块都以插件的形式存在，即各领域的功能都各自松散的做实现，这样使得底层能力更具通用性，同时扩展能力也更强，用户甚至也可以封装自己的插件。

业务部分更多是对于不同宿主环境的多入口适配，当前支持浏览器、Weex以及NodeJS。
```

* 内存泄漏和内存溢出有什么区别
```
内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。

内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光

引起内存溢出的原因
1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
3.代码中存在死循环或循环产生过多重复的对象实体；
4.使用的第三方软件中的BUG；
5.启动参数内存值设定的过小

重点排查
1.检查代码中是否有死循环或递归调用。
2.检查是否有大循环重复产生新对象实体。
3.检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。、
```

* 你是如何排查js内存泄漏的？造成内存泄漏的操作有哪些？
```
使用chrome面板的Performance和Memory

当我们怀疑页面发生了内存泄漏的时候，可以先用Performance录制一段时间内页面的性能变化如果录制结束后，看到内存的下限在不断升高的话，你就要注意了 —— 这里有可能发生了内存泄漏。除了内存增长曲线，Nodes（Dom节点数曲线）、Document曲线以及Listener曲线也同样值得关注，有时候它们对内存问题的定位也很有帮助。当你怀疑发生了内存泄漏的时候，你就可以用Memory面板来进一步定位泄漏的源头了

记录当前的堆内存快照（heap snapshot）,查看Shallow size 和 Retained size
它们有什么不同？
Shallow size: 这是对象自身占用内存的大小。通常只有数组和字符串的shallow size比较大。
Retain size: 这是将对象本身连同其无法从 GC 根到达的相关对象一起删除后释放的内存大小。 因此，如果Shallow Size = Retained Size，说明基本没怎么泄漏。而如果Retained Size > Shallow Size，就需要多加注意了。

造成内存泄漏的操作有
1. 意外创建的全局变量，即使用了未声明的变量而创建了一个全局变量，这个变量一直留在内存中无法被回收
2. 设置了setInterval，忘记取消它。如果回调函数有对外部变量引用的话，那么这个变量会一直留在内存中无法被回收
3. 我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收
4. 不合理的使用闭包，从而导致某些变量一直被留在内存当中
5. dom引用，当dom元素被删除时，内存中的引用未被正确清空
6. 控制台console.log打印的东西
```

* ReferenceError和TypeError有什么区别？
```
ReferenceError（引用错误）对象代表当一个不存在（或尚未初始化）的变量被引用时发生的错误。
TypeError（类型错误）对象通常（但并不只是）用来表示值的类型非预期类型时发生的错误。

以下情况会抛出 TypeError：
1. 传递给运算符的操作数或传递给函数的参数与预期的类型不兼容
2. 尝试修改无法更改的值
3. 尝试以不适当的方法使用一个值。
```
* 说下你对面向对象的理解
```
面向对象是一种编程思想，是将现实问题构建关系，然后抽象成 类 ( class )，给类定义属性和方法后，再将类实例化成 实例 (instance) ，通过访问实例的属性和调用方法来进行使用
```
* 举例说明面向对象编程有什么优缺点？
```
优点：封装、继承、抽象、多态
1. 设计和实现分离
2. 扩展性高
3. 易用性、复用性

不足
大量的创建对象会占用大量的内存空间，因此性能不如面向过程编程高，不太适用于开发一些计算机底层的应用，例如芯片开发，单片机开发等
```
* 你是如何做前端性能分析的？从哪些方面入手？有哪些指标？

* 举例说明什么是响应式编程？
* 你知道什么是纯函数吗？
* 什么是函数式编程？它有什么优缺点？

* 举例说明为什么说ES模块比commonJS模块还优秀？
* 请说说commonJS模块与ES模块的差异有哪些？
* 说说你对js中的依赖注入的理解，它的实现方式有哪些呢？
* 日常开发中写JS循环时应该注意哪些情况？
* js循环的数据量很大（例如100W+）时会出现什么情况？如何进行性能优化？
* 你是如何比较js函数的执行速度的？

* 如何排查页面中CPU占用高的情况？
* javascript什么时候会占CPU？
* 在chrome中js的数组占用了多少内存？
* 举例说明哪些场景会遇到超大计算量的问题？
* 请说说DOM节点的操作如何优化？
* 字符串拼接有哪些方式？哪种性能好？

* 如何设计一个pageAPI？说说你的方法
* 有什么方案可以提高无限滚动列表的性能
* 在js中怎么捕获异常？写出来看看？应该在哪些场景下采用呢？

* 一次JS的请求哪些地方会有缓存处理？
* js如何实现函数缓存？函数缓存有什么运用场景？
* 说说你对堆栈跟踪的理解
* 使用try catch哪些异常是捕获不到的？哪些能捕获到？捕获不到的要怎样才能捕获到？
* js的请求一般情况下在哪些地方会有缓存的处理？
* SeaJS和RequireJS有什么区别？
* 如果要你自己实现一个requireJS库，你该怎么做？
* 请使用js实现商品的sku，并说说你的思路
* 举例说明Object.defineProperty会在什么情况下造成循环引用导致栈溢出？
* xss攻击原理？如何防御？
* csrf 攻击是怎样攻击的？ 如何防御？
* js延迟加载的方式有哪些？

* 请为什么说js是单线程，而不是多线程呢？
* 为什么说js是弱类型语言，它的优缺点分别是什么？
* ES5和ES6、ES7有什么区别？
* 你平时是怎么调试js的？会断点调试吗？断点调试有什么技巧呢？
* js垃圾回收的方式有哪些？
* 说出至少十条你理解的js规范
* 请说说你对try/catch的理解，平时有在哪些场景会用到呢？
* 说说你对异常处理和错误处理的理解
* js依赖注入的实现思路是什么？它有什么优缺点呢？
* 说下你对IoC的理解，它有什么运用场景？
* 你了解什么是AOP吗？它的作用是什么？举个例子
* ES6 代码转成 ES5 代码的实现思路是什么？大致说一下 babel 原理? 
* 鼠标滚动的时候，会触发很多次事件，你是如何解决的？

### 异步
* 你是如何更好地处理Async/Await的异常的？
* 假设要在UI渲染之前处理一些事情你该怎么办？
* 实现异步编程有哪些方式？推荐用哪种？
* promise有哪几种状态？是如何变化的？
* Promise和setTimeout执行先后有什么区别？
* promise的构造函数是同步执行还是异步执行，它的then方法呢？
* 如何取消promise？
* 请说说你对promise的理解
* setTimeout(fn,0)，延迟执行吗？
* 请解释下setTimeout的运行机制
* setTimeout和setInterval有什么区别呢？
* setTimeout的第三个参数有什么用？
* 如何捕获 setTimeout 异常
* 切换标签窗口后js定时器自动停止了，如何在激活标签后又继续呢？
* 你对事件循环有了解吗？说说看！
* 解释下JavaScript并发模型
* js循环中调用异步的方法，如何确保执行结果的顺序是正确的？
* 现在有一个宏任务，又有一个微任务两者同一层级，在微任务里面又有一个宏任务和一个微任务，请问执行顺序是什么,为什么？
* 微任务和宏任务有什么区别？
* 异步请求重试策略有哪些呢？
* 前端异步的使用场景有哪些？
* 说说你理解的同步和异步的区别是什么？
* js异步加载有哪些方案？
* 异步加载和延迟加载有什么区别？
* requestIdleCallback在EventLoop的什么阶段执行？如何执行？
* requestAnimationFrame在EventLoop的什么阶段执行？
* EventLoop有优点但也有缺点，请说说它的缺点是什么？
* 你知道什么是空闲回调(requestIdleCallback)吗？
* 接口请求时需要做哪些安全处理？怎么做？
* ajax请求地址只支持http/https吗？能做到让它支持rtmp://等其它自定义协议吗 ？
* 说说防止重复发送ajax请求的方法有哪些？各自有什么优缺点？
* ajax如何接收后台传来的图片？
* 一个api接口从请求数据到请求结束共与服务器进行了几次交互？
* axios拦截器原理是什么？
* axios为什么可以使用对象和函数两种方式调用？是如何实现的？
* fetch和axios请求的原理都是基于XMLHttpRerequst吗？
* 使用ajax轮询接口有什么优缺点？
* 在axios中怎样添加授权验证？
* Ajax请求中get和post方式有什么区别呢？分别在哪些场景下使用？
* formData主要是用来做什么的？它的操作方法有哪些？
* fetch 和 ajax 区别
* axios如何一次发送多个并发请求
* 请详细描述AJAX的工作原理
* 请描述下ajax的请求都有哪些步骤？
* 说说CORS为何要区分预检请求和简单请求呢？
* 你知道什么是PAJAX吗？它和AJAX有什么区别？它的应用场景有哪些？
* axios为什么能在浏览器中环境运行又能在node中环境运行？
* ajax请求中为何会出现OPTIONS请求？
* pjax和ajax的区别是什么？
* 你有使用过pjax吗？它的原理是什么？
* 使用ajax请求真的不安全吗？为什么？
* axios相比原生ajax的优点有哪些呢？
* ajax的请求状态有哪几种？
* 请说说json和jsonp的区别？
* JSONP的原理是什么？解决什么问题？
* 当用户刷新网页时，js的请求有哪些地方会有缓存处理呢？
* 页面的编码和被请求的资源编码不一致时如何处理？
* 手写一个 Ajax

### 数据结构与算法
* 说一下递归和迭代的区别是什么，各有什么优缺点？
* 说说你对js排序的理解，你有了解哪些算法呢？举例说明数组的排序方法有哪些？
* 分析下'sum = n * (n - 1) / 2'的时间复杂度是什么？
* 一个好的算法都应包含哪些要素？
* 请解释下算法有什么特征（基本要素）？
* 请解释下数据结构与算法的关系
* 说说你对数据结构和数据类型的理解
* 哈希表的原理是什么？
* 如果要让你去实现一个散列函数，你将从哪些方面考虑？
* 什么是散列函数？它有什么特征？
* 是否所有的循环都能用递归代替？为什么？如果不可以，请举例说明
* 你觉得递归好写吗？
* 解释下深度优先遍历和广度优先遍历的区别及如何实现
* 为什么js里定义的数组可以不定长且数据类型可以不固定呢？
* js最大支持多少长度的数组？为什么？
* 说说你对稀疏数组的理解
* 举例说明你对尾递归的理解，它有什么应用场景？
* 举例说明js中什么是尾调用优化？
* Number()的存储空间是多大？假如接口返回一个超过最大字节的数字怎么办？
* 使用js按贝格尔编排算法生成单循环对阵表
* 构造一个自定义二维 N*N 矩阵，从左上角第一个单元格依次填入1 - N*N的数字，从矩阵中指定单元格出发，经过相邻的单元格(不可重复)，走 X 步，输出所有可能的路径和每条路径单元格对应的数字。
* 计算从一个大数组中(如1万条数据)取出第一数据和最后一条数据的时间分别是多少？
```
时间相同，数组一种线性表数据结构，用一组连续的内存空间，来存储一组具有相同类型的数据。数组是用连续内存空间存储相同类型的元素，就是因为有这个限制条件，使得数组按照下标随机访问(随机访问：可以用同等的时间访问到一组数据中的任意一个元素)数组中数据元素时间复杂度达到 O(1) 级别
```
* 什么是UUID？它有什么作用？用js写一个生成UUID的方法
```
UUID 是 通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，亦为开放软件基金会组织在分布式计算环境领域的一部分。

UUID 用于解决 ID 唯一的问题，主要确保唯一

生成方式
1. 使用Math.random()
2. 使用crypto提供的randomUUID方法
3. 使用crypto提供的getRandomValues方法
```
* 实现 10 进制转换为 36 进制


### BOM
* 如何解决在手机上长时间点击会选中图
* js操作节点的方法有哪些？
* 为什么jsonp不支持post的方法？
* document.write和innerHTML有什么区别？
* 如何使用js来截图？怎样截可见区域和整个页面？
* 添加原生事件如果不移除为什么会内存泄露？
* 使用原生js给一个按钮绑定两个onclick事件
* 如何监听浏览器窗口大小变化？
* 请说说html、body、document、window四者的区别是什么？
* window对象和document对象有什么区别？
* 请说说你对事件冒泡机制的理解？
* 移动端点击事件为什么会有延迟？有哪些方法可以解决？
* AudioContext有什么应用场景？
* 如何按回车自动提交表单
* 在设置keyup监听事件后按F5刷新和按浏览器中刷新键刷新有什么区别？
* innerHTML与outerHTML有什么区别？
* Geolocation.getCurrentPosition()用来做什么的？在什么浏览器不受兼容？
* document.domain的作用是什么？它有什么限制？
* 说下你对alert的理解，它有哪些特性呢？及使用它时要注意些什么？
* 如何创建视频文件的blob？
* 举例说明createDocumentFragment和createElement有什么区别？
* 解释下点击一个input输入框，依次会触发哪些事件？
* 如何区分返回内容是文件流还是json数据？
* 请问，javascript可以读取本地的文件吗？为什么？
* js的控制台输出，平时除了用console.log外，你还知道哪些？使用console.log应该注意什么？
* 平时调试用console.log的输出结果可信吗？为什么？
* 用原生js获取DOM元素的方法有哪些？
* W3C的事件处理和IE的事件处理有哪些区别？
* 你对window的属性devicePixelRatio有了解吗？说说它有什么实际应用场景？
* 举例说明你对事件代理的理解
* 解释下offsetWidth、clientWidth、scrollWidth这三者的区别是什么？
* 举例说明常用的BOM属性和方法有哪些？
* 各浏览器的事件机制有什么不同？ 如何阻止事件冒泡？
* 举例说明js拖拽用到的事件有哪些？
* onload事件和domcontentloaded哪个先执行呢？
* 返回到顶部的方法有哪些？把其中一个方法出来
* "attribute"和"property"有什么不同？
* 为什么会有跨域问题？怎么解决跨域？
* document的load 和ready有什么区别？
* 什么是事件委托？它有什么好处？能简单的写一个例子吗？
* 有用过HTML5的WebWork吗？它主要解决了什么问题？
* 如何终止WebWork？
* 请解释下什么是cookie隔离？为什么要隔离？如何隔离？
* 举例说明什么是decodeURI()和encodeURI()是什么？
* 请描述你对浏览器同源策略的理解
* 把Script标签放在页面最底部的\<\/body>之前和之后有什么区别？浏览器会如何解析它们？
* 写例子说明如何给li绑定事件（ul下有1000+个li）？
* 要实现一个js的持续动画，你有什么比较好的方法？
* 不依赖第三方库，说下如何使用js读取pdf？
* 不用第三方库，说说纯js怎么实现读取和导出excel？
* 能否正确获取本地上传的文件路径？如果可以怎么做？如果不可以解释下为什么？
* 请说说escape、encodeURI、decodeURI、encodeURIComponent和decodeURIComponent的区别？
* 你有用过webRTC吗？它有什么运用场景？
* 保护js代码的方式有哪些？分别说说他们的原理是什么？
* 举例说明js关闭当前窗口有哪些方法？
* 说说用原生js实现封装一个选项卡的功能
* 用js实现页面局部打印和预览原理是什么呢？同时在IE上有什么不同？
* 阻止事件的默认行为有哪些？说说它们之间的区别是什么？
* 请举例说明动态操作DOM的方法有哪些？
* 你有使用过ExtJs吗？说说它的优缺点是什么？
* 你有使用过BackboneJS吗？说说它和vue有什么区别？
* js事件中currentTarget和target的区别是什么？
* 写例子说明js中自定义事件的使用与触发
* getelementbyId和queryselect平时经常使用哪一个？说说你的看法
* 如何实现锁定网页、密码解锁的效果？说说你的方法和步骤是什么？
* 在js中attribute和property的区别是什么？
* 你有使用过FileReader吗？说说它有哪些应用场景？
* stopPropagation()和preventDefault()这两个方法有什么区别？
* 你有用过哪些3D渲染的库？
* 如果让你把把html页面导出为pdf，不用插件的话，你该怎么做？
* pageshow和pageshide有什么应用场景呢？
* 有了解过getSelection API吗？怎么使用，有哪些场景？
* window.console.log()和console.log()有区别吗？体现在哪里？
* 举例说明document.execCommand有哪些用途
* 说说你对postMessage的理解，它有什么运用场景呢？
```
window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全
```
* 用js封装一个前端分页的库，说说你的思路
* 页面上的DOM有多个相同的ID，用js获取时结果会是怎么样的？
* 如何在用户刷新、跳转、关闭浏览器时向服务端发送统计的数据？
* 在浏览器标签页之间切换触发的事件是哪个？
* 说说你对HTML5中video blob的理解
* 你觉得虚拟DOM快吗？还有没有比它还快的方式？
* DOM0、DOM2、DOM3事件处理方式的区别是什么？
* 有用过Handlebars模板引擎吗？它的工作原理是怎样的？
* 举例说明js鼠标事件有哪些？
* 微信的JSSDK都有哪些内容？如何接入？
* script所在的位置会影响首屏显示时间吗？
* 在DOM上同时绑定两个点击事件（一个用捕获，一个用冒泡），事件总共会执行几次，先执行哪个事件？
* flash如何与js交互？
* 在不支持js的浏览器中如何隐藏JavaScript代码？
* alert如何让文本换行？
* innerHTML有什么缺点？
* localStorage什么时候过期？
* 说说你对JSBridge的理解
* 写一个 document.querySelector 的逆方法
* 说说你对js沙箱的理解，它有什么应用场景？
* js源代码压缩都有哪些方法？它们的压缩原理分别是什么？
* 微信小程序实现轨迹回放，微信原生小程序，基于uniapp的小程序？
* 你用过Navigator.sendBeacon()吗？说说它有什么应用场景？
* async属性诞生的初衷是什么？
* 你能用js模拟出右键的复制和粘贴功能吗？如果可以说下是如何操作的？如果不可以请说明下理由
* js延迟加载的方式中，只有IE浏览器支持的是哪一种方式
* 当用户打开一个网页时，想一直停留在当前打开的页面，如何禁止页面前进和后退
* 前端下载文件的方式有哪些？
* 使用window.open(url)下载文件时为什么会被浏览器拦截？如何解决？
* sessionStrorage也可以使用onstorage事件吗?
* 动态加载的li如何绑定事件？
* getComputedStyle和element.style有什么不同？
* 说说MutationObserver的应用场景有哪些？
* 在多个页面之间需要传递参数，你是如何传递这些参数的？
* 怎样做到js无阻塞加载？
* 什么情况下会出现js阻塞？
* cookie的值可以设置为中文吗？为什么？如果可以怎么设置？
* 你有用过哪些模板引擎？你觉得哪个好用？为什么？
* 浏览器中window.length的结果是什么？为什么？
* 浏览器中的剪切板是如何监听复制事件的？
* 使用js如何改变url参数值，并且页面不刷新？
* 举例说明判断浏览器是否支持某个事件的方法有哪些？
* 请说说focus、blur与focusin、focusout的区别是什么？
* url链接中如果有两个问号会出现什么问题？如果通过js获取url的参数时能正常获取到吗？
* 请问css/html/js/img的下载顺序是怎样的？都是并发执行的吗？

### 对象
* callee和caller的区别和作用是什么？
* js的sort方法运用场景有哪些？
* 如何让js的filter方法支持大小写？
* 举例说明这三种方法map、reduce和filter的区别是什么？
* 说说你对ArrayBuffer的理解！它和Array有什么区别？
* js能够保证object属性的输出顺序吗？如果可以怎么做？
* 对象的键可以重复吗？为什么？如果可以重复将会又什么样的表现？
* 举例说明js创建数组有哪些方法？
* 如果使用JSON.stringify进行深拷贝有什么弊端？如何解决？
```
1. 函数
2. undefined
3. 循环引用
```
* 请说说你对内置对象和宿主对象的理解
* 深拷贝里的循环引用如何解决？
* js中Iterable对象和Array有什么区别？
* map和forEach有什么区别？

* 使用delete删除数组，其长度会改变吗？
* js的循环结构有哪些？
* 如何判断两个对象相等？
* 说说你对js对象生命周期的理解
* Math.ceil()、Math.round()、Math.floor()三者的区别是什么？
* js的数组/对象在内存中分别是如何存储的？
* 如何判断一个对象是否为空？
* 举例说明数组和对象的迭代方法分别有哪些？
* 说说你对深浅拷贝的理解？并实现一个对数组和对象深拷贝的方法
* 举例说明js如何实现继承？
* 说说你对arguments的理解，它是数组吗？
* json和对象有什么区别？
* 如何判断对象是否属于某个类？
* ArrayBuffer和Blob有什么区别？
* 遍历数组和对象的方法都有哪些？
* 举例说明object.freeze有哪些用途呢？
* 原生Math的方法有哪些？请列举并描述其功能
* 写出几种创建对象的方式，并说说他们的区别是什么？
* 深度克隆对象的方法有哪些，并把你认为最好的写出来
* 说说你对js包装对象的理解
* 说说你对base64的理解，它的使用场景有哪些？
* 举例说明atob和btoa的用法
* 简要描述下JS有哪些内置的对象
* 清空一个数组的方式有哪些？它们有什么区别
* 解释下如下代码的意图：Array.prototype.slice.apply(arguments)
* for in 和 for of 的区别？
* 使用for-in语句能保证遍历对象的顺序吗？如果不能那为什么？如果可以那又如何保证？
* 你知道js的可选链是什么吗？说说你对它的理解，它有什么应用场景？
* 请比较下for、forEach、for of的性能的性能
* 说说js跳出循环return、break、continue的区别？
* JSON.stringify有什么局限性和哪些技巧？
* 请举例说明JSON.stringify()有哪些特性？
* 请说下你对__proto__和prototype的理解
* 请描述下什么是原型模式？它主要运用在哪些场景？
* 请描述下js的原型和原型链的理解以及它们之间的关系
* 字符串从哪里来的split方法和length属性？
* new Function有什么应用场景？
* js怎样避免原型链上的对象共享？
* 原生的字符串操作方法有哪些？请列举并描述其功能
* 字符串相连有哪些方式？哪种最好？为什么？
* 举例说明如何使用WebSQL？

### 作用域与上下文
* 说一下 JavaScript 的执行流程
* 什么是词法分析？请描述下js词法分析的过程？
* js的函数有哪几种调用形式？
* 说说你对执行上下文的理解
* js函数调用方式有哪些？
* js函数定义方式有哪些？
* 在js中函数返回多个值有哪些方法？
* 函数声明与函数表达式有什么区别？
* 请描述下函数的执行过程
* 纯函数和函数式编程有什么关系？
* 为什么要用纯函数？
* 为什么eval要添加括号呢？
* 举例说明constructor和instanceof的区别是什么？
* 说下你对柯里化函数(currying)的理解，它有什么运用场景？
* 说下你对函数的形参与实参的理解
* js怎么实现一个类并实例化这个类？
* 举例说明什么是匿名函数？它有什么优缺点呢？
* 请解释下执行栈有哪些特点？
* 一个函数调用会产生多少个上下文环境？
* 请解释下为什么我们可以在声明函数前使用它？
* 说说你对函数是一等公民的理解
* 写一个函数时，如果有多个参数，如何传才比较好？
* 说说你对javascript的作用域的理解
* 闭包是如何形成的？
* 请说说你对活动对象的理解
* 请说说你对变量对象的理解
* 如果给你一段代码，你能画出执行过程的上下文堆栈的变化吗？
* 如何激活一个上下文？
* 在严格模式下，全局作用域中函数中this的值是什么？
* 请说说严格模式下的this指向
* 分别解释下js中默认绑定、隐式绑定、显式绑定、new绑定的区别
* 请解释下什么是softbind，并实现一个softbind
* js的作用域有哪些？
* 解释下什么是暂时性死区？
* class和普通构造函数有什么区别？
* 函数的调用栈是怎么工作的？
* 请说说JS中的索引数组、关联数组和静态数组、动态数组的定义与区别
* 使用js如何创建一个private方法？
* Array(3)和Array(3, 4)的区别是什么？
* js的哪些操作可以改变作用域链？
* 解释下隐式全局变量和外部函数作用域
* 说说你对JS中暂性死区的理解，它有什么运用场景？
* 说说你对作用域链的理解
* 举例说明什么是IIFEs？它有什么好处？
* 说说你对this的理解？写出4个使用this的典型例子
* 说说你对IIFE的理解
* 说说你对模块化的理解
* 说说你对eval的理解
* 什么是闭包？优缺点分别是什么？
* 你对new操作符的理解是什么？手动实现一个new方法
* 箭头函数的this值继承于哪里
* 下面代码是否会导致堆栈溢出错误
```js
function foo() {
  setTimeout(foo, 0);
}
foo();
// 是否存在堆栈溢出错误
```
* 写出执行结果，并解释为什么？
```
  <script>
    // 使用未定义的变量
    a;
    console.log(1);
  </script>
  <script>
    console.log(2);
  </script>
```
答案解析
```
答案
报错 2

分析
对于 Javascript 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。

所以上述过程如下：

当前代码块将作为一个任务压入任务队列中，JS 线程会不断地从任务队列中提取任务执行。
当任务执行过程中出现异常，且异常没有捕获处理，则会一直沿着调用栈一层层向外抛出，最终终止当前任务的执行。
JS 线程会继续从任务队列中提取下一个任务继续执行。
```

### 冷门
---
* 简要描述下什么是回调函数并写一个例子出来
* 举例说明你对TypedArray的理解，它的运用场景有哪些？
* 什么时候在JS中使用Float32Array而不是Array？
* Float32Array有几种构造方式？
* for(;;)循环里如果省略第二个条件，则需要注意什么问题？
* 解释下3 + "2" - 5的值为多少？
* null是对象吗？
* 请写出几种匿名自执行的写法（至少三种）
* 用js写出死循环的方法有哪些？
* 分析('b' + 'a' + +'a' + 'a').toLowerCase()返回的结果
* 解释下这段代码的意思！：[].forEach.call($$("*"),function(a){ a.style.outline="1px solid #"+(~~(Math.random()*(1<<24))).toString(16) })
* 请分析!+[]+!![]+!![]+!![]+!![]+!![]的结果
* 请快速答出此题的答案并解释：var x, y = 1; x + y = ?
* 准确说出'1,2,3,4'.split()的结果是什么（包括类型和值）？
* 请举例说明比较运算符`>,>=,<,<=`的比较规则
* 一道变态题 Number.call.call(Number, undefined, 0) 等于什么？
* 请说说IEEE 754规定了哪些标准？
* 请说说IEEE 754标准指的是什么？
* typeof('abc')和typeof 'abc'都是string, 那么typeof是操作符还是函数？
* 举例说明json的标准格式
* 举例说明js立即执行函数的写法有哪些？
* XML与JSON有什么的区别？
* JQuery的源码看过吗？能不能简单概括一下它的实现原理？
* 列举出JS的全局函数
* getElementById和querySelector方法的区别是什么？