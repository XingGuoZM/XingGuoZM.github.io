# 渲染优化

### 关键渲染路径

1. 解析HTML得到DOM树，解析CSS得到CSSOM树
2. 将DOM树和CSSOM树结合得到渲染树（Render Tree）
3. 布局（Layout）：根据生成的渲染树，确定页面上所有内容的大小和位置
4. 绘制（Painting）：根据渲染树及布局得到的几何信息，得到节点的绝对像素
5. 展示（Display）：将像素发给GPU，GPU会将多个合成层合并为一个层，展示在页面上

### 构建DOM和构建CSSOM
关键词：编码、css属性继承、媒体查询、js加载和执行

解析DOM具体过程读取HTML原始字节->根据文件指定编码（utf-8）将他们转化成字符串->将字符串转换成token，Token会标识出当前的token是开始标签或是结束标签亦或者是文本等信息->生成节点对象并且构建DOM，一边生成Token一边消耗Token来生成节点对象，例如生成出html的token并消耗token创建出html节点对象，然后生成head的token创建出head的节点对象并将它关联到html节点对象的子节点中，以此类推，直到所有token都消耗完，我们就得到一颗完整的DOM树

>Bytes -> Characters -> Tokens -> Nodes -> DOM
>
构建CSSOM过程和DOM类似，有几点需要注意的，
第一css规则是级联的，子节点会自动继承祖先节点的样式，即层叠规则；
第二HTML可以逐步解析，CSSOM和DOM的构建是同时进行的。
第三CSSOM必须构建完成才能进入下一阶段。

因为CSSOM的构建阻塞渲染，所以需要css性能优化，构建 CSSOM 非常非常快
1. 删除不必要的样式，对其进行最小化、压缩和缓存，
2. 基于媒体查询将css分成多个文件，通过link标签引入，并添加媒体查询
3. css动画，处理触发重排的动画属性，将动画节点从主线程移至GPU上，这些属性包括3D 变换（transform: translateZ()、rotate3d() 等）、动画变换、opacity、position: fixed、will-change 和 filter。一些元素，例如video标签、canvas标签 和iframe标签，也位于各自的图层上。将元素提升为图层（也称为合成）时，动画转换属性将在 GPU 中完成
4. will-change属性，告诉浏览器元素的哪些属性需要修改，使浏览器能够在元素实际更改之前设置优化，通过在实际更改前执行耗时的工作以提升性能。
5. font-display、contain属性，font-display 属性定义了浏览器如何加载和显示字体文件，允许文本在字体加载或加载失败时显示回退字体。可以通过依靠折中无样式文本闪现使文本可见替代白屏来提高性能
6. css选择器，更少的特定选择器是比更多的要快，更具体的规则，浏览器需要更多的工作，这带来的消耗通常很小

js是一门轻量级的解释型语言，浏览器接受到 JavaScript 代码，并以代码自身的文本格式运行它，当 JavaScript 源代码被执行时，它会被编译成二进制的格式，代码自上而下运行，且实时返回运行结果。

JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。js不仅可以改DOM，也可以更改样式，如果在CSSOM尚未构建完成，此时通过js操作css，那么js将延迟执行，DOM构建也将阻塞，等到CSSOM构建完成之后才恢复

DOMContentLoaded和defer：浏览器的 DOMContentLoaded 事件，其标志了 HTML 文档体完全加载和解析，defer属性的作用是用它告知浏览器在遇到script标签 元素时继续下载 HTML 内容,不会阻塞构建DOM树

script标签async和defer：浏览器遇到 async 脚本时不会阻塞页面渲染，而是直接下载然后运行。但是，一旦下载完成，脚本就会执行，从而阻止页面渲染，当页面的脚本之间彼此独立，且不依赖于本页面的其他任何脚本时，async 是最理想的选择。defer 属性加载的脚本将按照它们在页面上出现的顺序加载。在页面内容全部加载完毕之前，脚本不会运行，如果脚本依赖于 DOM 的存在（例如，脚本修改了页面上的一个或多个元素），可以使用defer。

async：脚本将在下载完成后立即执行。这将阻塞页面，并不保证任何特定的执行顺序
defer：脚本将按照在页面中出现的顺序加载和运行，并且在html解析完成之后才顺序执行

### 渲染树（Render Tree）
渲染树只包含了可见内容，如果有元素上有 display: none;，它本身和其后代都不会出现在渲染树中。

### 布局（Layout）和绘制（Painting）
关键词：viewport、盒子模型

Layout输出每个页面元素的盒模型，它能准确布局、处理元素排列，确保所有元素在视口内的尺寸、位置等（如图片等不知尺寸的元素提供占位空间），并且所有相对测量值都会转化为屏幕上的绝对像素值。确定视口大小，布局通常从body开始。

Painting：绘制是一个非常快的过程，将元素的每个可视部分绘制到屏幕上，包括文本、颜色、边框、阴影和替换的元素（如按钮和图像）。绘制可以将布局树中的元素分解为多个层。将内容提升到 GPU 上的层（而不是 CPU 上的主线程）可以提高绘制和重新绘制性能。有一些特定的属性和元素可以实例化一个层，包括 video标签 和 canvas标签，任何 CSS 属性为 opacity 、3D transform、will-change 的元素，还有一些其他元素

Compositing：当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。回流会触发重绘和合成，我们定义了图片大小，那么就不需要全部重绘，只需要重绘修改点；如果没有定义图片大小，那么就会全部重绘。


### 首屏直出渲染
1. 首屏尽量是静态页面
2. 首屏服务端渲染

### 防止阻塞渲染
1. css优先加载和解析，js延迟加载
2. script标签 defer和async

### 减少重绘和回流

1. 使用transform来完成动画
2. 批量修改dom（fragment）
