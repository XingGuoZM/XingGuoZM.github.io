
## å­—ç¬¦ä¸²
* å†™ä¸€ä¸ªå‡½æ•°ï¼Œå»é™¤å­—ç¬¦ä¸²ä¸­çš„ç©ºæ ¼
```js
const replaceEmpty = (str) => {
  return str.replace(/\s/g, '');
}
```
* å†™ä¸€ä¸ªå‡½æ•°ï¼Œåœ¨ç»™å®šä¸€ä¸ªurlå­—ç¬¦ä¸²è·å–å‚æ•°çš„æ–¹æ³•
```js
const getUrlParams = (str) => {

  const paramArr = str.split('?')[1].split('&');
  const obj = {};
  for (const item of paramArr) {
    const arr = item.split('=');
    if (!arr[1]) {
      obj[arr[0]] = true;
    } else {
      obj[arr[0]] = arr[1];
    }
  }
  return obj;
}

console.log(getUrlParams('https://baidu.com?a=1&b=undefined&c'))
```
* å†™ä¸€ä¸ªå‡½æ•°ï¼Œåˆ¤æ–­æ˜¯å¦å›æ–‡
```js
const isPalindrome = (str) => {
  let left = 0, right = str.length - 1;
  while (left < right) {
    if (str[left++] === str[right--]) {
      return false;
    }
  }
  return true;
}

console.log(isPalindrome('abd ba'))
```

* ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œæœ€å¤šåˆ é™¤ä¸€ä¸ªå­—ç¬¦ã€‚åˆ¤æ–­æ˜¯å¦èƒ½æˆä¸ºå›æ–‡å­—ç¬¦ä¸²ã€‚ ä¾‹å¦‚è¾“å…¥â€œabaâ€ï¼Œè¾“å‡ºâ€œTrueâ€ï¼›è¾“å…¥â€œabcaâ€,è¾“å‡ºâ€œTrueâ€
```js
const check = (str, left, right) => {
  while (left < right) {
    if (str[left++] !== str[right--]) return false;
  }
  return true;
}

const isPalindromeBydel1 = (s) => {
  let left = 0;
  let right = s.length - 1;
  while (left < right) {
    if (s[left] != s[right]) {
      return check(s, left, right - 1) || check(s, left + 1, right);
    } else {
      ++left;
      --right;
    }
  }
  return true;
}

console.log(isPalindromeBydel1('abca'))
```
* å†™ä¸€ä¸ªå‡½æ•°ï¼Œå®ç°å­—ç¬¦ä¸²çš„åè½¬
```js
// æ–¹æ³•ä¸€
const strReverse1 = (str) => {
  return str.split('').reverse().join('');
}
// æ–¹æ³•äºŒ
const strReverse2 = (str) => {
  let result = '';

  for (let i = str.length - 1; i >= 0; i--) {
    result += str[i];
  }
  return result;
}
```
* å†™ä¸€ä¸ªå‡½æ•°ï¼Œå®ç°ä¸¤ä¸ªå¤§æ•°ç›¸åŠ 
```js
const sum = (a, b) => {
  const len = Math.max(a.length, b.length);
  a = a.padStart(len, '0')
  b = b.padStart(len, '0')
  let curry = 0;
  let result = ''
  for (let i = len - 1; i >= 0; i--) {
    const sum = +a[i] + +b[i] + curry;

    result = sum % 9 + result;
    curry = Math.floor(sum / 9);
  }
  return curry ? curry + result : result;
}
//æµ‹è¯•
console.log(sum('123456789099888','111111111111111111111111111111111111'));
```
* å†™ä¸€ä¸ªå‡½æ•°ï¼Œåˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä¸ºå¦ä¸€ä¸ªå­—ç¬¦ä¸²çš„å­ä¸²
```js
// æ–¹å¼ä¸€
const isSubStr1 = (str1, str2) => {
  const longStr = str1.length > str2.length ? str1 : str2;
  const shortStr = str1.length < str2.length ? str1 : str2;

  return longStr.indexOf(shortStr) > -1 ? true : false;
}
// æ–¹å¼äºŒ
const isSubStr2 = (str1, str2) => {
  const longStr = str1.length > str2.length ? str1 : str2;
  const shortStr = str1.length < str2.length ? str1 : str2;

  for (let i = 0; i < longStr.length - shortStr.length; i++) {
    const s = longStr.slice(i, shortStr.length);
    if (s === shortStr) {
      return true;
    }
  }
  return false;
}
// æ–¹å¼ä¸‰
const isSubStr3 = (str1, str2) => {
  return str1.includes(str2) || str2.includes(str1);
}
```
* å†™ä¸€ä¸ªæ ¼å¼åŒ–é‡‘é¢çš„æ–¹æ³•
* å°† 153812.7 è½¬åŒ–ä¸º 153,812.7
* å®ç°æ ¼å¼åŒ–è¾“å‡ºï¼Œæ¯”å¦‚è¾“å…¥ 999999999ï¼Œè¾“å‡º 999,999,999
* å†™ä¸€ä¸ªå‡½æ•°ï¼Œå®ç°å­—ç¬¦ä¸²æ•°å­—çš„æ ¼å¼åŒ–ï¼Œä¾‹å¦‚100000->100,000
```js
// æ–¹å¼ä¸€ï¼šæ­£åˆ™
const formatNumStr = (numStr) => {
  return numStr.replace(/(?=\B(\d{3})+$)/g, ',')
}

console.log(formatNumStr('100000000'))
```
* å†™ä¸€ä¸ªå‡½æ•°ï¼Œå®ç°é¢œè‰²è½¬æ¢ 'rgb(255, 255, 255)' -> '#FFFFFF' çš„å¤šç§æ€è·¯
```js
const rgb2hex=(rgb)=>{
  const rgbList = rgb.match(/\d+/g);
  const hex = (n) => {
    return ("0" + Number(n).toString(16)).slice(-2);
  }
  return rgbList.reduce((pre,cur)=>pre+hex(cur),'#').toUpperCase()
}

//æµ‹è¯•
console.log(rgb2hex('rgb(255,255,255)'));
```
* å†™ä¸€ä¸ªå‡½æ•°ï¼Œå®ç°é¢œè‰²è½¬æ¢ '#FFFFFF' -> 'rgb(255, 255, 255)' çš„å¤šç§æ€è·¯
```js
const hex2rgb=(hex)=>{
  const ret = [];
  for(let i = 1; i < hex.length; i+=2) {
    const str = `0x${String(hex[i])}${String(hex[i+1])}`;
    ret.push(parseInt(str));
  }
  return `rgb(${ret.join(',')})`;
}
//æµ‹è¯•
console.log(hex2rgb('#000000'));
```
* å®ç°normalizeå‡½æ•°ï¼Œèƒ½å°†è¾“å…¥çš„ç‰¹å®šçš„å­—ç¬¦ä¸²è½¬åŒ–ä¸ºç‰¹å®šçš„ç»“æ„åŒ–æ•°æ®ï¼Œå­—ç¬¦ä¸²ä»…ç”±å°å†™å­—æ¯å’Œ [] ç»„æˆï¼Œä¸”å­—ç¬¦ä¸²ä¸ä¼šåŒ…å«å¤šä½™çš„ç©ºæ ¼ã€‚ç¤ºä¾‹ä¸€: 'abc' --> {value: 'abc'}ã€‚ç¤ºä¾‹äºŒï¼š'[abc[bcd[def]]]' --> {value: 'abc',children: {value: 'bcd', children: {value: 'def'}}}
```js
function normalize (str) {
  let treeObj = {};
  str.split(/[\[\]]/g).filter(Boolean).reduce((object, curr, index, a) => {
    object.value = curr;
    if (index !== a.length - 1) {
      return object.children = {}
    }
  }, treeObj);
  return treeObj;
}
// æµ‹è¯•
console.log(normalize('[abc[bcd[def]]]'));
```

* å†™ä¸€ä¸ªæ–¹æ³•ï¼Œå°†å­—ç¬¦ä¸²ä¸­çš„å•è¯å€’è½¬åè¾“å‡ºï¼Œå¦‚ï¼š`my love` -> `ym evol`
```js
const reverseWords = (str) => {
  return str.split(' ').map(item => {
    return item.split('').reverse().join('')
  }).join(' ');;
}
// æµ‹è¯•
const str = 'my love';
console.log(reverseWords(str));
```

* å†™ä¸ªæ–¹æ³•ï¼Œæ‰¾å‡ºæŒ‡å®šå­—ç¬¦ä¸²ä¸­é‡å¤æœ€å¤šçš„å­—ç¬¦åŠå…¶é•¿åº¦
```js
function getMaxChar (str) {
  const obj = {}
  for (let i = 0; i < str.length; i++) {
    if (obj[str[i]]) {
      obj[str[i]] += 1
    } else {
      obj[str[i]] = 1;
    }
  }
  let maxChar = [], maxCount = -1
  for (let char in obj) {
    if (!obj.hasOwnProperty(char)) {
      continue;
    }
    if (obj[char] === maxCount) {
      maxChar.push(char);
    } else if (obj[char] > maxCount) {
      maxChar = [char];
      maxCount = obj[char];
    }
  }
  return { maxChar, maxCount };
}
// æµ‹è¯•
const str = 'abbc';
const { maxChar, maxCount } = getMaxChar(str);
console.log(maxChar, maxCount);
```

* å†™ä¸€ä¸ªå­—ç¬¦ä¸²é‡å¤çš„repeatå‡½æ•°ï¼Œä¾‹å¦‚repeat('abc',4) // abcabcabcabc
```js
// æ–¹æ³•ä¸€ï¼šnew Array + join
const repeat = (str, count) => {
  return (new Array(count + 1)).join(str)
}
//æ–¹æ³•äºŒ:é€’å½’
const repeat = (str, count) => {
  return count > 0 ? str.concat(repeat(str, --count)) : ''
}
// æ–¹æ³•ä¸‰ï¼šå¾ªç¯

//æµ‹è¯•
const str = 'abc';
const count = 5;
console.log(repeat(str, count))
```

* è¯·å†™å‡ºä¸€ä¸ªå‡½æ•°æ±‚å‡ºNçš„é˜¶ä¹˜ï¼ˆå³N!ï¼‰
```js
// é€’å½’
function factorialByRecursion (n) {
  if (n === 1) return n;
  return n * factorial(n - 1)
}
//å¾ªç¯
function factorialByLoop (n) {
  let sum = 1;
  for (let i = 1; i <= n; i++) {
    sum *= i;
  }
  return sum;
}
// æµ‹è¯•
console.log(factorialByLoop(10))
```
* æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æœ€é•¿çš„å•è¯ï¼Œå¹¶è¿”å›å®ƒçš„é•¿åº¦
```js
function getMaxStr (str) {
  const arr = str.split(' ');
  return arr.map(item => item.length).reduce((val, cur) => val > cur ? val : cur);
}

const str = 'my name is jason'
console.log(getMaxStr(str));
```

* å†™ä¸€ä¸ªæ–¹æ³•æŠŠä¸‹åˆ’çº¿å‘½åè½¬æˆå¤§é©¼å³°å‘½å
* å†™ä¸€ä¸ªæ–¹æ³•æŠŠä¸­åˆ’çº¿å‘½åè½¬æ¢æˆå°é©¼å³°å‘½å
* å†™ä¸€ä¸ªæ–¹æ³•æŠŠå°é©¼å³°å‘½åè½¬æ¢æˆä¸­åˆ’çº¿å‘½å
```js
// å‘½åæ–¹å¼ä¸­åˆ’çº¿æ”¹å°é©¼å³°
const format2Camel = function (str) {
  return str.replace(/-[a-zA-Z]/g, match => match.replace('-', '').toUpperCase())
}
// å‘½åæ–¹å¼å°é©¼å³°æ”¹ä¸­åˆ’çº¿
const format2Line = function (str) {
  return str.replace(/[A-Z]/g, match => '-' + match.toLowerCase());
}

const str = 'elButtonList';
const ans = format2Line(str);
console.log(ans);
```

* å†™ä¸€ä¸ªæ–¹æ³•æŠŠ0å’Œ1äº’è½¬ï¼ˆ0ç½®1ï¼Œ1ç½®0ï¼‰
```js
const convert = num=>num^1;
```

* å†™ä¸€ä¸ªæ–¹æ³•éªŒè¯æ˜¯å¦ä¸ºä¸­æ–‡
```js
const isContainChinese = (str) => /[\u4e00-\u9FFF]/g.test(str)
```
* å†™ä¸€ä¸ªéªŒè¯èº«ä»½è¯å·çš„æ–¹æ³•
```js
const isValidIdCard = str =>/^[1-9]\d{5}(18|19|20)\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/g.test(str)
```
* è¾“å…¥ä¸€ä¸ªå››åˆ™æ··åˆè¿ç®—çš„è¡¨è¾¾å¼ï¼Œè¯·å†™ä¸ªæ–¹æ³•æ±‚å®ƒçš„å€¼
* åˆ†åˆ«å°è£…ç²¾ç¡®è¿ç®—çš„åŠ å‡ä¹˜é™¤å››ä¸ªæ–¹æ³•
```js
// åˆ†åˆ«å°è£…ç²¾ç¡®è¿ç®—çš„åŠ å‡ä¹˜é™¤å››ä¸ªæ–¹æ³•

String.prototype.numberAdd = function (number) {

  const Max = Math.max(this.length, number.length);
  let curry = 0;
  let n1 = this.padStart(Max, '0');
  let n2 = number.padStart(Max, '0');
  let sum = '';
  for (let i = Max - 1; i >= 0; i--) {
    const temp = Number(n1[i]) + Number(n2[i]) + curry;
    sum = temp % 10 + sum;
    curry = temp > 9 ? 1 : 0;
  }
  return curry === 1 ? '1' + sum : sum;
}
String.prototype.numberMinus = function (number) {
  const Max = Math.max(this.length, number.length);
  let curry = 0;

  let flag = true;
  let n1 = this.padStart(Max, '0');
  let n2 = number.padStart(Max, '0');
  if (Number(this) <= (number)) {
    n1 = number.padStart(Max, '0');
    n2 = this.padStart(Max, '0');
    flag = false;
  }
  let ans = ''
  for (let i = Max - 1; i >= 0; i--) {
    let num1 = Number(n1[i]), num2 = Number(n2[i])
    curry === 1 && num1--;
    curry = num1 < num2 ? 1 : 0;
    const temp = num1 + 10 * curry - num2;

    ans = temp + ans;
  }
  return flag ? ans : `-${Number(ans)}`;
}
String.prototype.numberMultiply = function (number) {
  const n1 = Number(this);
  const n2 = Number(number);
  const min = n1 < n2 ? n1 : n2;
  const max = n1 < n2 ? number : this;
  let sum = '';
  for (let i = 0; i < min; i++) {
    sum = sum.numberAdd(max)
  }
  return sum;
}
String.prototype.numberDivide = function (number) {
  let t1 = 0
  let t2 = 0
  let r1
  let r2
  try {
    t1 = this.split('.')[1].length
    t2 = number.split('.')[1].length
  } catch (e) { }
  r1 = Number(this.replace('.', ''))
  r2 = Number(number.replace('.', ''))
  return (r1 / r2) * Math.pow(10, t2 - t1)
}

console.log('2'.numberDivide('3'));
```
* éšæœºç”Ÿæˆä¸€ä¸ªæŒ‡å®šé•¿åº¦çš„éªŒè¯ç 
* å†™ä¸€ä¸ªæ–¹æ³•ç”Ÿæˆä¸é‡å¤çš„ç”¨æˆ·ID
* å†™ä¸€ä¸ªæ–¹æ³•éšæœºç”ŸæˆæŒ‡å®šä½æ•°çš„å­—ç¬¦ä¸²
```js
const generateStr = (n) => {
  let str = Math.random().toString(36).substr(2);
  return str.length >= n ? str.substr(0, n) : str + generateStr(n - str.length);
}

console.log(generateStr(15));
```
* å»é™¤å­—ç¬¦ä¸²ä¸­æœ€åä¸€ä¸ªæŒ‡å®šçš„å­—ç¬¦
```js

function delLast(str,target) {
  let reg =new RegExp(`${target}(?=([^${target}]*)$)`)
  return str.replace(reg,'')
}
```

* å†™ä¸€ä¸ªæ–¹æ³•æ£€æµ‹é¡µé¢ä¸­çš„æ‰€æœ‰æ ‡ç­¾æ˜¯å¦æ­£ç¡®é—­åˆ
```js
const areAllTagsClosed = html => {
	const template = document.createElement('template');
	template.innerHTML = html;
	return template.innerHTML === html;
}
```
* å†™ä¸€ä¸ªåŠ å¯†ï¼ˆè§£å¯†ï¼‰å­—ç¬¦ä¸²çš„æ–¹æ³•
```js
//åŠ å¯†
function encryptStr (str, key) {
  let ans = '', b, b1, b2, b3;
  const len = key.length;
  for (let i = 0; i < str.length; i++) {
    b = str.charCodeAt(i);
    b1 = b % len;
    b = (b - b1) / len;
    b2 = b % len;
    b = (b - b2) / len;
    b3 = b % len;
    ans += key[b1] + key[b2] + key[b3];
  }
  return ans;
}
// è§£å¯†
function decryptStr (str, key) {
  const keyLen = key.length;
  const ansLen = Math.floor(str.length / 3);
  let ans = new Array(ansLen), b1, b2, b3, d = 0;
  for (let i = 0; i < ansLen; i++) {
    b1 = key.indexOf(str.charAt(d++));
    b2 = key.indexOf(str.charAt(d++));
    b3 = key.indexOf(str.charAt(d++));
    ans[i] = b1 + b2 * keyLen + b3 * keyLen * keyLen;
  }
  return String.fromCharCode(...ans);
}
const key = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const str = 'Â¥'
const s1 = encryptStr(str, key)
const s2 = decryptStr(s1, key)

console.log(s1, s2)
```
* ç»Ÿè®¡æŸä¸€å­—ç¬¦æˆ–å­—ç¬¦ä¸²åœ¨å¦ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•°
```js
const getStrCount = (str, target) => str.match(new RegExp(target, 'g')).length;

console.log(getStrCount('abcabc', 'ab'))
```
* å†™ä¸€ä¸ªå»é™¤åˆ¶è¡¨ç¬¦å’Œæ¢è¡Œç¬¦çš„æ–¹æ³•
```js
const deTab = (str) => str.replace(/[\t\r\f\n]*/g, '')
console.log(deTab(
  `abc

`))

```
* å†™ä¸€ä¸ªæŠŠå­—ç¬¦ä¸²å¤§å°å†™åˆ‡æ¢çš„æ–¹æ³•
```js

function isUpperCase (char) {
  return str.charCodeAt(i) >= 65 && str.charCodeAt(i) <= 90
}
function changeCharCode (str) {
  let ans = ''
  for (let i = 0; i < str.length; i++) {
    ans += isUpperCase(str[i]) ? str[i].toLowerCase() : str[i].toUpperCase();
  }
  return ans;
}

console.log(changeCharCode('abcARF'));
```
* å¦‚ä½•è¯†åˆ«å‡ºå­—ç¬¦ä¸²ä¸­çš„å›è½¦\nå¹¶è¿›è¡Œæ¢è¡Œï¼Ÿ
```js
const replaceReturn = (str) =>str.replace(/\n/g, '<br/>');
```
* è®¡ç®—ç»™å®šçš„å­—ç¬¦ä¸²æ‰€å çš„å­—èŠ‚æ•°
```js
const isSingleByte = (char) => /^[\u0000-\u00ff]$/.test(char)
function getStrBytes (str) {
  let count = 0;
  for (let i = 0; i < str.length; i++) {
    isSingleByte(str[i]) ? count++ : count += 2;
  }
  return count;
}

console.log(getStrBytes('hello ä¸­å›½'))
```

* å†™ä¸ªæ–¹æ³•æ‰¾å‡ºé¡µé¢ä¸­é™¤äº†æ•°å­—å’Œè‹±æ–‡å­—æ¯å¤–çš„æ‰€æœ‰ç‰¹æ®Šç‰¹å·
```js
function getSpecialChar (str) {
  return str.replace(/[A-Za-z0-9]/g, '')
}
```
* å†™ä¸€ä¸ªæ–¹æ³•ï¼Œå½“ç»™å®šæ•°å­—ä½æ•°ä¸è¶³8ä½æ—¶ï¼Œåˆ™åœ¨å·¦è¾¹è¡¥å……0ä»¥è¡¥è¶³8ä½æ•°çš„æ–¹æ³•
```js
function padStartby0 (num, str) {
  if (num < str.length) return str;
  return new Array(num - str.length).fill(0).join('') + str;
}

console.log(padStartby0(2, '123'))
```

* å†™ä¸€ä¸ªæ–¹æ³•å°†å­—ç¬¦ä¸²ä¸­çš„åˆ¶è¡¨ç¬¦å…¨éƒ¨æ›¿æ¢ä¸ºé€—å·
```js
function replaceTab2Comma (str) {
  return str.replace(/\u0020/g, ',')
}

console.log(replaceTab2Comma('abcd  dfed'))
```
* å†™ä¸€ä¸ªä½¿ä¸¤ä¸ªæ•´æ•°è¿›è¡Œäº¤æ¢çš„æ–¹æ³•ï¼ˆä¸èƒ½ä½¿ç”¨ä¸´æ—¶å˜é‡ï¼‰
```js
let a =1,b=13
a ^= b;
b ^= a;
a ^= b;
```
* ç»™å®šç‰¹å®šçš„å­—ç¬¦ä¸²ï¼Œå†™ä¸ªæ–¹æ³•åˆ¤æ–­æ˜¯å¦ä»¥å…ƒéŸ³å­—æ¯ç»“å°¾
```js
function isEndWithVowel (str) {
  return /[a,e,i,o,u]$/i.test(str)
}

console.log(isEndWithVowel('hellU'))
```
* å†™ä¸€ä¸ªæ–¹æ³•æ‰¾å‡ºä¸€æ®µè¯é‡Œé¢å‡ºç°é¢‘ç‡æœ€å¤šçš„è¯
```js

function getHighestRateWord (texts) {
  const arr = (',' + texts).split(/\W+/)
  let words = '';
  let count = -1;
  const map = {};
  for (let item of arr) {
    item = item.toLowerCase();
    map[item] = (map[item] || 0) + 1;
    if (count < map[item]) {
      words = item;
      count = map[item]
    }
  }
  return { words, count }
}
const str = 'I have a pen, I have an apple, Uh! apple pen. Pen pineapple apple pen.'

console.log(getHighestRateWord(str))
```
* é˜¿æ‹‰ä¼¯æ•°å­—å’Œä¸­æ–‡æ•°å­—çš„äº’è½¬çš„æ–¹æ³•,ä¾‹å¦‚ï¼š101è½¬æˆä¸€ç™¾é›¶ä¸€ã€ä¸€ç™¾é›¶ä¸€è½¬æˆ101
```js
// æ¥æºï¼šhttps://juejin.cn/post/6892372242143903758
function NumberConvert () {
  this.NumberMap = 'é›¶ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹';
  this.UnitMap = {
    'å': 10,
    'ç™¾': 100,
    'åƒ': 1000,
    'ä¸‡': 10000,
    'äº¿': 100000000
  }
  this.ChinaUnit = [''
    , 'å', 'ç™¾', 'åƒ', 'ä¸‡'
    , 'å', 'ç™¾', 'åƒ', 'äº¿'
    , 'å', 'ç™¾', 'åƒ', 'ä¸‡'
    , 'å', 'ç™¾', 'åƒ', 'äº¿'
  ];
  // 
  this.arabic2China = function (num) {
    if (!num || isNaN(num)) {
      return "é›¶";
    }
    const str = String(num);
    const len = str.length;
    let result = "";
    for (let i = 0; i < len; i++) {
      // åå‘æ˜ å°„æ•°å­—
      const number = this.NumberMap[str[len - 1 - i]];
      // æ­£å‘æ˜ å°„å•ä½
      const unit = this.ChinaUnit[i];
      result = number + unit + result;
    }
    return result
      .replace(/é›¶(åƒ|ç™¾|å)/g, 'é›¶')
      .replace(/åé›¶/g, 'å')
      .replace(/é›¶+/g, 'é›¶')
      .replace(/é›¶äº¿/g, 'äº¿')
      .replace(/é›¶ä¸‡/g, 'ä¸‡')
      .replace(/äº¿ä¸‡/g, 'äº¿')
      .replace(/é›¶+$/, '')
      .replace(/^ä¸€å/g, 'å');
  }
  this._transform = function (str) {
    if (!str) return 0;
    const stack = [];
    for (let i = 0; i < str.length; i++) {
      const n = this.NumberMap.indexOf(str[i]);
      const u = this.UnitMap[str[i]];
      if (n >= 0) stack.push(n)
      if (u >= 0) stack.push((stack.pop()) * u)
    }
    return stack.reduce((acc, item) => acc + item, 0);
  }
  this._format = function (str) {
    return str[0] === 'å' ? `ä¸€${str}` : str
  };
  this.china2Arabic = function (str) {
    const splitChar = ['äº¿', 'ä¸‡'];
    let s = str;
    for (const char of splitChar) {
      const arr = s.split(char);
      if (arr.length === 2) {
        return this._transform(this._format(arr[0])) * this.UnitMap[char] + this.china2Arabic(arr[1]);
      }
      s = arr[0];
    }
    return this._transform(this._format(s));
  }
}


const convert = new NumberConvert();
const s = convert.arabic2China(8)
const n = convert.china2Arabic(s);
console.log(s, n)
```
* å†™ä¸€ä¸ªæ±‰å­—ä¸Unicodeç çš„äº’è½¬çš„æ–¹æ³•
```js
// æ±‰å­— -> unicodeç¼–ç 
function str2Unicode (str) {
  let result = ''
  for (let i = 0; i < str.length; i++) {

    result += `&#${str.charCodeAt(i)};`;
  }
  return result;
}
// unicodeç¼–ç ä¸² -> æ±‰å­—
function unicode2Str (unicode) {
  const code = unicode.match(/&#(\d+);/g);
  let result = '';
  for (let i = 0; i < code.length; i++) {
    result += String.fromCharCode(code[i].replace(/[&#;]/g, ''))
  }
  return result;
}
```
* å†™ä¸€ä¸ªå¯†ç ç”Ÿæˆå™¨ï¼Œå¹¶åŒæ—¶å†™ä¸€ä¸ªå¯†ç å¼ºåº¦æ ¡éªŒçš„æ–¹æ³•
```js
function checkStrength (password) {
  const regArr = [
    /[a-z]/g,// å°å†™
    /[A-Z]/g, // å¤§å†™
    /[0-9]/g,// æ•°å­—
    /[!@#$%^&*()_+=<>?:{}]/g // ç‰¹æ®Šå­—ç¬¦
  ]
  let level = 0;
  for (const reg of regArr) {
    if (reg.test(password)) {
      level++
    }
  }
  return level;
}

// åœ¨[start,end]åŒºé—´å†…ç”Ÿæˆä¸€ä¸ªéšæœºæ•´æ•°
const getRandom = (start, end) => start + Math.floor(Math.random() * (end - start));
// åœ¨[start,end]åŒºé—´é‡Œç”Ÿæˆnä¸ªä¸é‡å¤çš„éšæœºæ•´æ•°
const getRandomN = (n, start, end) => {
  const set = new Set();
  while (set.size < n) set.add(getRandom(start, end));
  return [...set];
}
// ç”Ÿæˆå¼ºåº¦ä¸ºlevelï¼Œé•¿åº¦ä¸ºnçš„å¯†ç ä¸²
function getPassword (n, level) {

  const Seeds = [
    'abcdefghijklmnopqrstuvwxyz',
    'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
    '0123456789',
    '!@#$%^&*_+=?:',
  ];
  let res = '';
  const indexArr = getRandomN(level, 0, Seeds.length);
  let targetChars = ''
  for (const item of indexArr) {
    res += Seeds[item][getRandom(0, Seeds[item].length)]
    targetChars += Seeds[item];
  }

  const remainArr = getRandomN(n - level, 0, targetChars.length)
  for (const item of remainArr) {
    res += targetChars[item];
  }
  return res;
}
```
* å†™ä¸€ä¸ªæ–¹æ³•åˆ¤æ–­ç»™å®šçš„å­—ç¬¦ä¸²æ˜¯å¦åŒæ€(isomorphic),åŒæ€ï¼šä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œå¦‚æœAå­—ç¬¦ä¸²ä¸­çš„æ¯ä¸€ä¸ªå­—ç¬¦éƒ½å¯ä»¥åœ¨Bå­—ç¬¦ä¸²ä¸­æ‰¾åˆ°å”¯ä¸€å¯¹åº”ï¼Œå¹¶ä¸”é¡ºåºä¸€ä¸€å¯¹åº”ï¼›å¦‚æœå­˜åœ¨è¿™æ ·çš„å‡½æ•°ï¼Œé‚£ä¹ˆAå’ŒBåŒæ€
```js
function isomorphic (str1, str2) {
  if (str1.length != str2.length) {
    return false;
  }
  let result = true;
  let map = {}
  for (let i = 0; i < str1.length; i++) {
    let code1 = str1.charCodeAt(i);
    let code2 = str2.charCodeAt(i);
    const dif = code1 - code2;
    if (map.hasOwnProperty(str1[i])) {
      return dif === map[str1[i]]
    } else {
      map[str1[i]] = dif
    }
  }
  return result;
}
```
* ä½¿ç”¨é€’å½’å®ç°æŒ‡å®šæœ€å°å€¼å’Œæœ€å¤§å€¼ä¹‹é—´çš„æ‰€æœ‰æ•´æ•°æ±‚å’Œ
```js
const sum = (start, end) => end * (end + 1) / 2 - start * (start - 1) / 2
```
* è¯·ä½¿ç”¨jså†™ä¸ªæ–¹æ³•è§£æemojiè¡¨æƒ…
```js
class EmojiUtil {

  _Start = 0x10000;
  _HighCode = 0xD800;
  _LowCode = 0xDC00;
  _Multiple = 0x400;

  _encode (char) {
    const high = (char.charCodeAt(0) - this._HighCode) * this._Multiple + this._Start;
    const low = char.charCodeAt(1) - this._LowCode;
    return `&#${high + low};`
  }
  _decode (code) {
    const len = code - this._Start;
    const high = Math.floor(len / this._Multiple) + this._HighCode;
    const low = (len % this._Multiple) + this._LowCode
    return String.fromCharCode(high, low);
  }
  //Â è¡¨æƒ…è½¬ç  emoji -> utf16
  encodeEmoji (emoji) {
    return emoji.replace(/[\ud800-\udbff][\udc00-\udfff]/g
      , (char) => {
        return char.length === 2 ? this._encode(char) : char
      }
    );
  }
  //Â è¡¨æƒ…è§£ç  utf16 -> emoji
  decodeEmoji (utf16) {
    return utf16.replace(/&#\d+;/g
      , s => this._decode(s.replace('&#', '').replace(';', ' '))
    );
  }
}

const util = new EmojiUtil();
const emoji = 'ğŸ‘‡ğŸ‘‰ğŸ‘ˆğŸ™ŒğŸ‘¨â€ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦';
const utf16 = util.encodeEmoji(emoji);
const retEmoji = util.decodeEmoji(utf16);
console.log(utf16, retEmoji);
```

* è¯·å®ç°ä¸€ä¸ªè®¡ç®—å™¨çš„åŠŸèƒ½
```js
// è¡¨è¾¾å¼è¿ç®—ï¼šæ­£æ•°å››åˆ™è¿ç®—
class Calculation {
  optionStack = [];
  numberStack = [];
  calc2Num (n1, n2, op) {
    switch (op) {
      case '+': return n1 + n2;
      case '-': return n1 - n2;
      case '*': return n1 * n2;
      case '/': return n1 / n2;
      default: throw Error('ä¸åˆæ³•è¿ç®—ç¬¦')
    }
  }
  isNumber = char => char.match(/[0-9]/g);
  isTopLvOp = char => char === '*' || char === '/'
  handleHighLvOp () {
    const len = this.optionStack.length;
    const topOp = len > 0 && this.optionStack[len - 1];
    if (this.isTopLvOp(topOp)) {
      const n1 = this.numberStack.pop();
      const n2 = this.numberStack.pop();
      const op = this.optionStack.pop();
      this.numberStack.push(this.calc2Num(n2, n1, op));
    }
  }
  handleLowLvOp () {
    return this.numberStack.reduce((acc, cur) => {
      return this.calc2Num(acc, cur, this.optionStack.shift());
    })
  }

  start (expression) {
    let i = 0;
    while (i < expression.length) {
      if (this.isNumber(expression[i])) {
        let currNum = '';
        while (i < expression.length && this.isNumber(expression[i])) {
          currNum += expression[i++];
        }
        this.numberStack.push(Number(currNum));
        this.handleHighLvOp();
      } else {
        this.optionStack.push(expression[i++]);
      }
    }
    return this.handleLowLvOp();
  }
}
```
* å†™ä¸€ä¸ªæ–¹æ³•æŠŠç§‘å­¦è®¡æ•°æ³•è½¬æ¢æˆæ•°å­—æˆ–è€…å­—ç¬¦ä¸²
```js
function sn2str (number) {
  const [a, b] = String(number).split('e').map(item => item.replace(/\./g, ''));
  if (b === void 0) return number;
  const len = b - (a.length - 1);
  return b > 0 ? a.padStart(len, 0) : `0.${a.padStart(-len, 0)}`;
}
```
* ä½¿ç”¨jså†™ä¸€ä¸ªæ–¹æ³•å°†æ•°å­—è½¬æ¢ä¸ºfloat,å¹¶å–Nä½å°æ•°
```js
function parseFloat (value, n) {
  const [a, b] = String(value).split('.')
  if (b === void 0)
    return value + '.'.padEnd(n + 1, 0);
  if (b.length <= n)
    return a + '.' + b.padEnd(n, 0);

  const pre = Number(b[n - 1]);
  const end = Number(b[n]);
  const curry = end >= 5 ? (pre + 1) : pre;
  return a + '.' + b.slice(0, n - 1) + curry;
}
```

* ä½¿ç”¨jså®ç°æ‘©æ–¯å¯†ç çš„åŠ å¯†å’Œè§£å¯†
* å†™ä¸€ä¸ªæ–¹æ³•ï¼Œå®æ—¶éªŒè¯inputè¾“å…¥çš„å€¼æ˜¯å¦æ»¡è¶³é‡‘é¢å¦‚ï¼š3.56(æœ€å¤šåªæœ‰ä¸¤ä½å°æ•°ä¸”åªèƒ½æ•°å­—å’Œå°æ•°ç‚¹)çš„æ ¼å¼ï¼Œå…¶å®ƒç‰¹æ®Šå­—ç¬¦ç¦æ­¢è¾“å…¥
* å†™ä¸€ä¸ªä»»æ„è¿›åˆ¶è½¬æ¢çš„ç¨‹åº

* å†™ä¸ªæ–¹æ³•å°†base64çš„æ•°æ®æµè£…æ¢ä¸ºäºŒè¿›åˆ¶æµ
* å†™ä¸€ä¸ªæ–¹æ³•å°†ArrayBufferè½¬ä¸ºå­—ç¬¦ä¸²
* ä½¿ç”¨æ­£åˆ™å»æ‰htmlä¸­æ ‡ç­¾ä¸æ ‡ç­¾ä¹‹é—´çš„ç©ºæ ¼
* å†™ä¸€ä¸ªæ–¹æ³•å°†ä¸€ä¸ªhtmlå­—ç¬¦ä¸²å˜æˆJSONæ ‘çš„å½¢å¼
* å†™ä¸€ä¸ªæ–¹æ³•å°†æ±‰å­—è½¬æ¢æˆæ‹¼éŸ³é¦–å­—æ¯
* å†™ä¸€ä¸ªæ–¹æ³•å®ç°æŒ‡å®šå¼€å§‹çš„æ•°å­—å¢åŠ åˆ°æŒ‡å®šçš„ç»“æŸæ•°å­—ï¼Œæ­¥é•¿é»˜è®¤ä¸º1
* å¦‚ä½•åˆ¤æ–­ä¸€ä¸ªå…ƒç´ æ–‡æœ¬æ˜¯å¦æ¢è¡Œï¼Ÿ
