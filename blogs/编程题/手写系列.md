### 手写原生方法
1. 考虑兼容性
2. 考虑方法本身特点

* 手写instanceof
```js
// 引用类型判断
const myInstanceof = (object,constructor)=>{
  let prototype = constructor.prototype;
  object = object.__proto__;
  while(true){
    if(!object) return false;
    if(prototype == object) return true;
    object = object.__proto__;
  }
}
```

* 手写let、const
```js
/**
 * 块级作用域下有效
 * 不能重复声明
 * 不能预处理，不存在变量提升，即未声明之前的代码不能调用
 */
  (function(){
    var i = 0;
    console.log(i)
  })()

  //const
/**
 * @param {*} key 
 * @param {*} value 
 * 用于声明一个常量
 * 块级作用域有效
 * 不能重复声明
 * 不能预处理，不存在变量提升，未声明之前不能调用
 * 不能修改
 * 声明时必须初始化
 */
function myConst(key,value){
  window[key]=value;
  Object.defineProperty(window,key,{
    enumerable:false,
    configurable:false,
    get:function(){
      return value;
    },
    set:function(newValue){
      if(newValue!==value){
        throw TypeError('这是只读变量，不可修改')
      }else{
        return value;
      }
    }
  })
}
```
* 手写一个new方法
```js
// 实现一：
const myNew = (fn,...args)=>{
  const obj = {};
  // 补齐原型链
  obj.__proto__ = fn.prototype;
  // 补齐this指向
  const ret = fn.call(obj,...args);
  return typeof ret === 'object' ? ret:obj;
}

// 实现二：
function myNew2(){

  const Constructor = [].shift.call(arguments);
  const obj = Object.create(Constructor.prototype);
  const ret = Constructor.apply(obj,arguments);
  return typeof ret === 'object' ? ret:obj;
}
```

* 手写一个call、bind的方法
```js
/*
* 思路：在指定的上下文对象里添加一个属性（目标函数）并执行
* 1. 确保ctx一定是一个对象
  2. 确保添加key的唯一性
*/
Function.prototype.myCall = function(ctx,...args){
  ctx = (ctx === undefined || ctx === null) ? globalThis : Object(ctx);
  var key = Symbol();
  var fn = this;
  Object.defineProperty(ctx,key,{
    enumerable:false,
    value:fn,
  })
  var ret = ctx[key](...args);
  delete ctx[key];
  return ret;
}
/*
*思路：将this与指定上下文对象绑定，返回一个函数
1. 参数合并
2. 判断bind之后的函数是不是构造函数
*/
Function.prototype.myBind = function (ctx) {
  ctx = (ctx === null || ctx === undefined) ? globalThis : Object(ctx);
  var args = Array.prototype.slice.call(arguments, 1);
  var fn = this;
  return function func () {
    var nextArgs = Array.prototype.slice.call(arguments);
    var allArgs = args.concat(nextArgs);
    if (Object.getPrototypeOf(this) === func.prototype) {
      var obj = { };
      Object.setPrototypeOf(obj, fn.prototype);
      fn.apply(obj, allArgs);
      return obj;
    }
    return fn.apply(ctx, allArgs);
  }
}

```
* 实现setTimeout、setInterval
```js
const mySetInterval=(cb,delay)=>{
  const context =this;
  const timer = setTimeout(()=>{
    cb.call(context);
    clearTimeout(timer);
    mySetInterval(cb,delay)
  },delay);
}
```
* 实现一个寄生式组合继承
* 手写一个继承函数
* 手写数组的map、filter、find方法
```js
Array.prototype.myMap = function (callback) {
  const arr = []
  for (let i = 0; i < this.length; i++) {
    arr[i] = callback(this[i], i);
  }
  return arr;
}

Array.prototype.myFilter = function (callback) {
  const arr = [];
  for (let i = 0; i < this.length; i++) {
    if (callback(this[i], i)) {
      arr.push(this[i]);
    }
  }
  return arr;
}

Array.prototype.myFind = function (callback) {
  for (let i = 0; i < this.length; i++) {
    if (callback(this[i], i)) {
      return this[i];
    }
  }
}

// 测试
const arr = [1, 2, 3, 4, 9, 5];
const mapArr = arr.myMap((item, index) => item + index);
console.log(mapArr);

const filterArr = arr.myFilter((item, index) => item > index);
console.log(filterArr);

const findArr = arr.myFind((item, index) => item === index);
console.log(findArr)
```
* 手写数组拉平方法(flat)
```js
// flat即根据指定深度递归将所有子元素拼接到新数组中
/**
 * 存在空项的数组
 * 类数组 arguments等
 */
Array.prototype.myFlat = function (depth = 1) {
  return this.reduce((pre, cur) => {
    return pre.concat(Array.isArray(cur) && depth > 1 ? cur.myFlat(depth - 1) : cur)
  }, [])
}

const arr = [1, 2, [3, 4, [5, 6, [7, { name: 'hello' }, [9, 10]]]]];
const arrayLike = {
  length: 3,
  0: [1, 2],
  // 嵌套的类数组对象不会被展平
  1: { length: 2, 0: 3, 1: 4 },
  2: 5,
};
console.log(arr.myFlat(Infinity));
console.log(Array.prototype.flat.call(arrayLike));
```
* 请实现一个flattenDeep函数，把多维数组扁平化
```js
Array.prototype.myFlatDeep = function (depth = 1) {
  return this.flat().reduce((pre, cur) => {
    return pre.concat(Array.isArray(cur) && depth > 1 ? cur.myFlat(depth - 1) : cur)
  }, [])
}

const arr = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];
console.log(arr.myFlatDeep(2));
```
* 使用js写个方法，使得数组的两个元素互换，要求高性能
* 使用js写一个方法，使得数组的某个元素置顶
* 写一个方法，让数组里的元素上移一格/下移一格
```js
Array.prototype.swap = function (i, j) {
  this[i] = this.splice(j, 1, this[i])[0];
  return this;
}
Array.prototype.movePrev = function (index) {
  this.swap(index, index - 1);
  return this;
}
Array.prototype.moveNext = function (index) {
  this.swap(index, index + 1);
  return this;
}

Array.prototype.moveTop = function (index) {
  while (index > 0) {
    this.movePrev(index--);
  }
  return this;
}
Array.prototype.moveBottom = function (index) {
  while (index < this.length - 1) {
    this.moveNext(index++);
  }
  return this;
}

const arr = [0, 1, 2, 3, 4, 5];
// console.log(arr.swap(2, 4));
console.log(arr.moveBottom(2));
```
* 分别写出数组的交集、并集、差集、补集这四个方法
```js
// 交集
Array.prototype.intersect = function (arr) {
  return this.filter(item => arr.includes(item));
}
// 差集
Array.prototype.minus = function (arr) {
  return this.filter(item => !arr.includes(item));
}
// 补集
Array.prototype.complement = function (arr) {
  return [...this.filter(item => !arr.includes(item)), ...arr.filter(item => !this.includes(item))]
}
// 并集
Array.prototype.unionset = function (arr) {
  return this.concat(arr.filter(v => !this.includes(v)))
}

const arr1 = [1, 2, 3, 4, 5];
const arr2 = [2, 4, 6, 8, 10]
console.log(arr1.intersect(arr2))
console.log(arr1.minus(arr2))
console.log(arr1.complement(arr2))
console.log(arr1.unionset(arr2))
```
* 手写数组indexOf
```js
const myIndexOf = (arr, item) => {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === item) return i;
  }
  return -1;
}
```
* 手写数组reduce
```js

const myReduce = (array, callback, initialValue) => {
  const fakeArray = [...array]
  if (initialValue) {
    fakeArray.unshift(initialValue);
  }
  let preValue = fakeArray[0];
  for (let i = 0; i < fakeArray.length - 1; i++) {
    preValue = callback(preValue, fakeArray[i + 1]);
  }
  console.log(preValue);
  return preValue;
}
```

* 用reduce实现map方法
```js
const mapFromReduce = (array, callback) => {
  return array.reduce((value, currValue, currIndex, array) => {
    value.push(callback(currValue, currIndex, array));
    return value;
  }, []);
}
```
* 手写数组排序方法(sort)
```js
// 快速排序
const quickSort = (arr)=>{
  const left =[];
  const right =[];
  const flag = arr.splice(0,1);
  for(let i=0;i<arr.length;i++){
    if(flag<arr[i]){
      right.push(arr[i]);
    }else{
      left.push(arr[i]);
    }
  }
  return quickSort(left).concat(flag,quickSort(right));
}
```
* 实现一个isNaN的方法
```js
Number.prototype.myIsNaN = function (num) {
  return num !== Number(num)
}
```
* 用js实现typeof的功能
* 请实现一个 JSON.stringfy
* 请实现一个 JSON.parse
```js
//方法一：eval
function jsonParse (opt) {
  return eval(`(${opt})`);
}
jsonParse(JSON.stringify({ x: 5 }))
// Object { x: 5}
jsonParse(JSON.stringify([1, "false", false]))
// [1, "false", false]
jsonParse(JSON.stringify({ b: undefined }))
// {}

// 方法二：Function
var func= new Function(arg1,arg2,...,functionBody);
var jsonStr = '{ "age": 20, "name": "jack" }'
var json = (new Function('return ' + jsonStr))()

```
* 原生实现 ES5 的 Object.create()方法
* 写一个方法实现js的函数重载
* 用js实现一个HashMap，不可以使用Object
* 写一个方法代替eval
