
  import React,{useEffect} from 'react';
 
  import 'highlight.js/styles/xcode.css';
  const hljs = require('highlight.js');

  export default () => {
    useEffect(()=>{
      document.querySelectorAll('code').forEach(el => {
        el.style.backgroundColor='#f8f8f8';
        el.style.marginBottom='0.1rem';
        hljs.highlightElement(el);
      });
    },[])
    return <div style={{fontSize:'0.26rem'}} dangerouslySetInnerHTML={{__html:"<h3>手写原生方法</h3>\n<ol>\n<li>考虑兼容性</li>\n<li>考虑方法本身特点</li>\n</ol>\n<ul>\n<li>手写instanceof</li>\n</ul>\n<pre><code class=\"language-js\">// 引用类型判断\nconst myInstanceof = (object,constructor)=>{\n  let prototype = constructor.prototype;\n  object = object.__proto__;\n  while(true){\n    if(!object) return false;\n    if(prototype == object) return true;\n    object = object.__proto__;\n  }\n}\n</code></pre>\n<ul>\n<li>手写let、const</li>\n</ul>\n<pre><code class=\"language-js\">/**\n * 块级作用域下有效\n * 不能重复声明\n * 不能预处理，不存在变量提升，即未声明之前的代码不能调用\n */\n  (function(){\n    var i = 0;\n    console.log(i)\n  })()\n\n  //const\n/**\n * @param {*} key \n * @param {*} value \n * 用于声明一个常量\n * 块级作用域有效\n * 不能重复声明\n * 不能预处理，不存在变量提升，未声明之前不能调用\n * 不能修改\n * 声明时必须初始化\n */\nfunction myConst(key,value){\n  window[key]=value;\n  Object.defineProperty(window,key,{\n    enumerable:false,\n    configurable:false,\n    get:function(){\n      return value;\n    },\n    set:function(newValue){\n      if(newValue!==value){\n        throw TypeError('这是只读变量，不可修改')\n      }else{\n        return value;\n      }\n    }\n  })\n}\n</code></pre>\n<ul>\n<li>手写一个new方法</li>\n</ul>\n<pre><code class=\"language-js\">// 实现一：\nconst myNew = (fn,...args)=>{\n  const obj = {};\n  // 补齐原型链\n  obj.__proto__ = fn.prototype;\n  // 补齐this指向\n  const ret = fn.call(obj,...args);\n  return typeof ret === 'object' ? ret:obj;\n}\n\n// 实现二：\nfunction myNew2(){\n\n  const Constructor = [].shift.call(arguments);\n  const obj = Object.create(Constructor.prototype);\n  const ret = Constructor.apply(obj,arguments);\n  return typeof ret === 'object' ? ret:obj;\n}\n</code></pre>\n<ul>\n<li>实现setTimeout、setInterval</li>\n</ul>\n<pre><code class=\"language-js\">const mySetInterval=(cb,delay)=>{\n  const context =this;\n  const timer = setTimeout(()=>{\n    cb.call(context);\n    clearTimeout(timer);\n    mySetInterval(cb,delay)\n  },delay);\n}\n</code></pre>\n<ul>\n<li>实现一个寄生式组合继承</li>\n<li>手写一个继承函数</li>\n<li>用reduce实现map方法</li>\n</ul>\n<pre><code class=\"language-js\">const mapFromReduce = (array, callback) => {\n  return array.reduce((value, currValue, currIndex, array) => {\n    value.push(callback(currValue, currIndex, array));\n    return value;\n  }, []);\n}\n</code></pre>\n<ul>\n<li>手写数组排序方法(sort)</li>\n<li>实现一个isNaN的方法</li>\n</ul>\n<pre><code class=\"language-js\">Number.prototype.myIsNaN = function (num) {\n  return num !== Number(num)\n}\n</code></pre>\n<ul>\n<li>用js实现typeof的功能</li>\n<li>请实现一个 JSON.stringfy</li>\n<li>请实现一个 JSON.parse</li>\n</ul>\n<pre><code class=\"language-js\">//方法一：eval\nfunction jsonParse (opt) {\n  return eval(`(${opt})`);\n}\njsonParse(JSON.stringify({ x: 5 }))\n// Object { x: 5}\njsonParse(JSON.stringify([1, &quot;false&quot;, false]))\n// [1, &quot;false&quot;, false]\njsonParse(JSON.stringify({ b: undefined }))\n// {}\n\n// 方法二：Function\nvar func= new Function(arg1,arg2,...,functionBody);\nvar jsonStr = '{ &quot;age&quot;: 20, &quot;name&quot;: &quot;jack&quot; }'\nvar json = (new Function('return ' + jsonStr))()\n\n</code></pre>\n<ul>\n<li>\n<p>原生实现 ES5 的 Object.create()方法</p>\n</li>\n<li>\n<p>写一个方法实现js的函数重载</p>\n</li>\n<li>\n<p>用js实现一个HashMap，不可以使用Object</p>\n</li>\n<li>\n<p>写一个方法代替eval</p>\n</li>\n<li>\n<p>手写函数常见方法</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">/*\n* 思路：在指定的上下文对象里添加一个属性（目标函数）并执行\n* 1. 确保ctx一定是一个对象\n  2. 确保添加key的唯一性\n*/\nFunction.prototype.myCall = function(ctx,...args){\n  ctx = (ctx === undefined || ctx === null) ? globalThis : Object(ctx);\n  var key = Symbol();\n  var fn = this;\n  Object.defineProperty(ctx,key,{\n    enumerable:false,\n    value:fn,\n  })\n  var ret = ctx[key](...args);\n  delete ctx[key];\n  return ret;\n}\n/*\n*思路：将this与指定上下文对象绑定，返回一个函数\n1. 参数合并\n2. 判断bind之后的函数是不是构造函数\n*/\nFunction.prototype.myBind = function (ctx) {\n  ctx = (ctx === null || ctx === undefined) ? globalThis : Object(ctx);\n  var args = Array.prototype.slice.call(arguments, 1);\n  var fn = this;\n  return function func () {\n    var nextArgs = Array.prototype.slice.call(arguments);\n    var allArgs = args.concat(nextArgs);\n    if (Object.getPrototypeOf(this) === func.prototype) {\n      var obj = { };\n      Object.setPrototypeOf(obj, fn.prototype);\n      fn.apply(obj, allArgs);\n      return obj;\n    }\n    return fn.apply(ctx, allArgs);\n  }\n}\n</code></pre>\n<ul>\n<li>手写数组常见方法</li>\n</ul>\n<pre><code class=\"language-js\">// reduce\nconst myReduce = (array, callback, initialValue) => {\n  const fakeArray = [...array]\n  if (initialValue) {\n    fakeArray.unshift(initialValue);\n  }\n  let preValue = fakeArray[0];\n  for (let i = 0; i < fakeArray.length - 1; i++) {\n    preValue = callback(preValue, fakeArray[i + 1]);\n  }\n  console.log(preValue);\n  return preValue;\n}\n// indexOf\nArray.prototype.myIndexOf = (item) => {\n  for (let i = 0; i < this.length; i++) {\n    if (arr[i] === item) return i;\n  }\n  return -1;\n}\n// map\nArray.prototype.myMap = function (callback) {\n  const arr = []\n  for (let i = 0; i < this.length; i++) {\n    arr[i] = callback(this[i], i);\n  }\n  return arr;\n}\n// filter\nArray.prototype.myFilter = function (callback) {\n  const arr = [];\n  for (let i = 0; i < this.length; i++) {\n    if (callback(this[i], i)) {\n      arr.push(this[i]);\n    }\n  }\n  return arr;\n}\n// find\nArray.prototype.myFind = function (callback) {\n  for (let i = 0; i < this.length; i++) {\n    if (callback(this[i], i)) {\n      return this[i];\n    }\n  }\n}\n// flat即根据指定深度递归将所有子元素拼接到新数组中\n/**\n * 存在空项的数组\n * 类数组 arguments等\n */\nArray.prototype.myFlat = function (depth = 1) {\n  return this.reduce((pre, cur) => {\n    return pre.concat(Array.isArray(cur) &amp;&amp; depth > 1 ? cur.myFlat(depth - 1) : cur)\n  }, [])\n}\n// flatDeep\nArray.prototype.myFlatDeep = function (depth = 1) {\n  return this.flat().reduce((pre, cur) => {\n    return pre.concat(Array.isArray(cur) &amp;&amp; depth > 1 ? cur.myFlat(depth - 1) : cur)\n  }, [])\n}\n// swap：元素交换\nArray.prototype.swap = function (i, j) {\n  this[i] = this.splice(j, 1, this[i])[0];\n  return this;\n}\n// movePrev：元素前移一格\nArray.prototype.movePrev = function (index) {\n  this.swap(index, index - 1);\n  return this;\n}\n// moveNext：元素后移一格\nArray.prototype.moveNext = function (index) {\n  this.swap(index, index + 1);\n  return this;\n}\n// moveTop：元素置顶\nArray.prototype.moveTop = function (index) {\n  while (index > 0) {\n    this.movePrev(index--);\n  }\n  return this;\n}\n// moveBottom：元素置底\nArray.prototype.moveBottom = function (index) {\n  while (index < this.length - 1) {\n    this.moveNext(index++);\n  }\n  return this;\n}\n// 交集\nArray.prototype.intersect = function (arr) {\n  return this.filter(item => arr.includes(item));\n}\n// 差集\nArray.prototype.minus = function (arr) {\n  return this.filter(item => !arr.includes(item));\n}\n// 补集\nArray.prototype.complement = function (arr) {\n  return [...this.filter(item => !arr.includes(item)), ...arr.filter(item => !this.includes(item))]\n}\n// 并集\nArray.prototype.unionset = function (arr) {\n  return this.concat(arr.filter(v => !this.includes(v)))\n}\n// 快排，时间复杂度（nlogn ～ n^2）\nArray.prototype.myQuickSort = function () {\n  if (this.length === 0 || this.length === 1) return this;\n  const tmp = this.shift();\n  const left = [];\n  const right = [];\n\n  for (const item of this) {\n\n    if (item < tmp) {\n      right.push(item);\n    } else {\n      left.push(item);\n    }\n  }\n  return left.myQuickSort().concat(tmp, right.myQuickSort());\n}\n//插入排序\nArray.prototype.myInsertSort = function () {\n  let temp;\n\n  for (let i = 1; i < this.length; i++) {\n    temp = this[i];\n    let j = i - 1;\n    while (j >= 0 &amp;&amp; temp < this[j]) {\n      this[j + 1] = this[j];\n      j--;\n    }\n    this[j + 1] = temp;\n  }\n  return this;\n}\n</code></pre>\n<ul>\n<li>手写字符串常见方法</li>\n</ul>\n<h3>startsWith: 用来判断当前字符串是否以另外一个给定的子字符串开头，并根据判断结果返回 true 或 false</h3>\n<pre><code class=\"language-js\">String.prototype.myStartsWith = function (searchString, position = 0) {\n  return this.slice(position, searchString.length) === searchString;\n}\n</code></pre>\n<h3>endsWith: 判断一个字符串是否以指定字符串结尾，如果是则返回 true，否则返回 false</h3>\n<pre><code class=\"language-js\">String.prototype.myEndsWith = function (searchString, endPosition = this.length) {\n  return this.slice(endPosition - searchString.length, endPosition) === searchString;\n}\n</code></pre>\n<h3>indexOf: 在字符串中搜索指定子字符串，并返回其第一次出现的位置索引</h3>\n<pre><code class=\"language-js\">String.prototype.myIndexOf = function (searchValue, position = 0) {\n  searchValue = String(searchValue);\n  var searchLen = searchValue.length;\n  var strLen = this.length;\n  for (var i = position; i <= strLen - searchLen; i++) {\n    if (this.slice(i, i + searchLen) === searchValue) {\n      return i;\n    }\n  }\n  return -1;\n}\n</code></pre>\n<h3>lastIndexOf: 搜索该字符串并返回指定子字符串最后一次出现的索引</h3>\n<pre><code class=\"language-js\">String.prototype.myLastIndexOf = function (searchValue, position = this.length) {\n  searchValue = String(searchValue);\n  var searchLen = searchValue.length;\n  var strLen = this.length;\n  for (var i = position; i >= strLen - searchLen; i--) {\n    if (this.slice(i - searchLen, i) === searchValue) {\n      return i;\n    }\n  }\n  return -1;\n}\n</code></pre>\n<h3>includes区分大小写的搜索，以确定是否可以在一个字符串中找到另一个字符串，并根据情况返回 true 或 false</h3>\n<pre><code class=\"language-js\">String.prototype.myIncludes = function (searchString, position = 0) {\n  return this.myIndexOf(String(searchString), position) > -1;\n}\n</code></pre>\n<h3>repeat: 构造并返回一个新字符串，其中包含指定数量的所调用的字符串副本，这些副本连接在一起。</h3>\n<pre><code class=\"language-js\">String.prototype.myRepeat = function (count) {\n  return count > 0 ? this.concat(this.myRepeat(--count)) : '';\n}\n</code></pre>\n<h3>获取指定长度的重复字符串</h3>\n<pre><code class=\"language-js\">String.prototype.myRepeatByLength = function (length) {\n  var padLen = this.length;\n  var temp = ''\n  for (var i = 0; i < length % padLen; i++) {\n    temp += this[i]\n  }\n  return this.myRepeat(Math.floor(length / padLen)) + temp;\n}\n</code></pre>\n<h3>padStart: 用另一个字符串填充当前字符串（如果需要会重复填充），直到达到给定的长度。填充是从当前字符串的开头开始的。</h3>\n<pre><code class=\"language-js\">String.prototype.myPadStart = function (targetLength, padString = ' ') {\n  if (this.length > targetLength) return this;\n  return padString.myRepeatByLength(targetLength - this.length) + this;\n}\n</code></pre>\n<h3>padEnd: 会将当前字符串从末尾开始填充给定的字符串（如果需要会重复填充），直到达到给定的长度。填充是从当前字符串的末尾开始的</h3>\n<pre><code class=\"language-js\">String.prototype.myPadEnd = function (targetLength, padString = ' ') {\n  if (this.length > targetLength) return this;\n  return this + padString.myRepeatByLength(targetLength - this.length);\n}\n</code></pre>\n<h3>trimStart: 从字符串的首端移除空白字符，返回一个新字符串</h3>\n<pre><code class=\"language-js\">String.prototype.myTrimStart = function () {\n  for (var i = 0; i < this.length; i++) {\n    if (this[i] !== ' ') return this.slice(i)\n  }\n  return this;\n}\n</code></pre>\n<h3>trimEnd: 从字符串尾端移除空白字符，返回一个新字符串</h3>\n<pre><code class=\"language-js\">String.prototype.myTrimEnd = function () {\n  for (var i = this.length - 1; i >= 0; i--) {\n    if (this[i] !== ' ') return this.slice(0, i + 1)\n  }\n  return this;\n}\n</code></pre>\n<h3>trim: 从字符串的两端移除空白字符，并返回一个新的字符串，而不会修改原始字符串</h3>\n<pre><code class=\"language-js\">String.prototype.myTrim = function () {\n  return this.myTrimStart().myTrimEnd();\n}\n</code></pre>\n"}}></div>
  }
  