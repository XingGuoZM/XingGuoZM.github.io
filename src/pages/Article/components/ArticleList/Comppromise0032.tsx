
  import React,{useEffect} from 'react';
 
  import 'highlight.js/styles/xcode.css';
  const hljs = require('highlight.js');

  export default () => {
    useEffect(()=>{
      document.querySelectorAll('code').forEach(el => {
        el.style.backgroundColor='#f8f8f8';
        el.style.marginBottom='0.1rem';
        hljs.highlightElement(el);
      });
    },[])
    return <div style={{fontSize:'0.26rem'}} dangerouslySetInnerHTML={{__html:"<h2>promise</h2>\n<ul>\n<li>手写promise，包括then，catch和finally</li>\n</ul>\n<pre><code class=\"language-js\">const PENDING = &quot;pending&quot;; \nconst FULFILLED = &quot;fulfilled&quot;; \nconst REJECTED = &quot;rejected&quot;;\nconst resolvePromise = (promise, x, resolve, reject) => {\n  if (x === promise) {\n    // If promise and x refer to the same object, reject promise with a TypeError as the reason.\n    reject(new TypeError('循环引用'))\n  }\n  // if x is an object or function,\n  if (x !== null &amp;&amp; typeof x === 'object' || typeof x === 'function') {\n    // If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.\n    let called\n    try { // If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.\n      let then = x.then // Let then be x.then\n      // If then is a function, call it with x as this\n      if (typeof then === 'function') {\n        // If/when resolvePromise is called with a value y, run [[Resolve]](promise, y)\n        // If/when rejectPromise is called with a reason r, reject promise with r.\n        then.call(x, y => {\n          if (called) return\n          called = true\n          resolvePromise(promise, y, resolve, reject)\n        }, r => {\n          if (called) return\n          called = true\n          reject(r)\n        })\n      } else {\n        // If then is not a function, fulfill promise with x.\n        resolve(x)\n      }\n    } catch (e) {\n      if (called) return\n      called = true\n      reject(e)\n    }\n  } else {\n    // If x is not an object or function, fulfill promise with x\n    resolve(x)\n  }\n}\nfunction Promise(excutor) {\n  let that = this; // 缓存当前promise实例例对象\n  that.status = PENDING; // 初始状态\n  that.value = undefined; // fulfilled状态时 返回的信息\n  that.reason = undefined; // rejected状态时 拒绝的原因 \n  that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数\n  that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数\n  function resolve(value) { // value成功态时接收的终值\n    if(value instanceof Promise) {\n      return value.then(resolve, reject);\n    }\n    // 实践中要确保 onFulfilled 和 onRejected ⽅方法异步执⾏行行，且应该在 then ⽅方法被调⽤用的那⼀一轮事件循环之后的新执⾏行行栈中执⾏行行。\n    setTimeout(() => {\n      // 调⽤用resolve 回调对应onFulfilled函数\n      if (that.status === PENDING) {\n        // 只能由pending状态 => fulfilled状态 (避免调⽤用多次resolve reject)\n        that.status = FULFILLED;\n        that.value = value;\n        that.onFulfilledCallbacks.forEach(cb => cb(that.value));\n      }\n    });\n  }\n  function reject(reason) { // reason失败态时接收的拒因\n    setTimeout(() => {\n      // 调⽤用reject 回调对应onRejected函数\n      if (that.status === PENDING) {\n        // 只能由pending状态 => rejected状态 (避免调⽤用多次resolve reject)\n        that.status = REJECTED;\n        that.reason = reason;\n        that.onRejectedCallbacks.forEach(cb => cb(that.reason));\n      }\n    });\n  }\n\n  // 捕获在excutor执⾏行行器器中抛出的异常\n  // new Promise((resolve, reject) => {\n  //     throw new Error('error in excutor')\n  // })\n  try {\n    excutor(resolve, reject);\n  } catch (e) {\n    reject(e);\n  }\n}\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  const that = this;\n  let newPromise;\n  // 处理理参数默认值 保证参数后续能够继续执⾏行行\n  onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : value => value;\n  onRejected = typeof onRejected === &quot;function&quot; ? onRejected : reason => {\n    throw reason;\n  };\n  if (that.status === FULFILLED) { // 成功态\n    return newPromise = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        try{\n          let x = onFulfilled(that.value);\n          resolvePromise(newPromise, x, resolve, reject); //新的promise resolve 上⼀一个onFulfilled的返回值\n        } catch(e) {\n          reject(e); // 捕获前⾯面onFulfilled中抛出的异常then(onFulfilled, onRejected);\n        }\n      });\n    })\n  }\n  if (that.status === REJECTED) { // 失败态\n    return newPromise = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        try {\n          let x = onRejected(that.reason);\n          resolvePromise(newPromise, x, resolve, reject);\n        } catch(e) {\n          reject(e);\n        }\n      });\n    });\n  }\n  if (that.status === PENDING) { // 等待态\n// 当异步调⽤用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中\n    return newPromise = new Promise((resolve, reject) => {\n      that.onFulfilledCallbacks.push((value) => {\n        try {\n          let x = onFulfilled(value);\n          resolvePromise(newPromise, x, resolve, reject);\n        } catch(e) {\n          reject(e);\n        }\n      });\n      that.onRejectedCallbacks.push((reason) => {\n        try {\n          let x = onRejected(reason);\n          resolvePromise(newPromise, x, resolve, reject);\n        } catch(e) {\n          reject(e);\n        }\n      });\n    });\n  }\n};\n</code></pre>\n<ul>\n<li>手写promise的all、race、allSettled</li>\n</ul>\n<pre><code class=\"language-js\">const all = (arr) => {\n  return new Promise((resolve,reject)=>{\n    const ret = [];\n    let count = 0;\n    for(let i=0;i<arr.length;i++){\n      arr[i].then(res=>{\n        ret[i] = res;\n        count++;\n        if(count === arr.length) {\n          resolve(ret);\n        }\n      }).catch(reject)\n    }\n  })\n}\nconst race = (arr) => {\n  return new Promise((resolve,reject)=>{\n    for(let i = 0;i<arr.length;i++){\n      arr[i].then(resolve).catch(reject);\n    }\n  })\n}\nconst allSettled = (arr)=>{\n  return new Promise((resolve,reject)=>{\n    const ret = [];\n    let count = 0;\n    for(let i=0;i<arr.length;i++){\n      arr[i].then(res=>{\n        ret[i] = res;\n      }).catch(err=>{\n        ret[i]=err;\n      }).finally(()=>{\n        count++;\n        if(count === arr.length) {\n          resolve(ret);\n        }\n      })\n    }\n  })\n}\n</code></pre>\n<ul>\n<li>手写promise的并发（limit）</li>\n</ul>\n<pre><code class=\"language-js\">\nconst request = (msg,delay)=>new Promise(resolve=>setTimeout(()=>resolve(msg),delay));\n\nconst arr = [\n  ()=>request(1,2000),\n  ()=>request(2,1000),\n  ()=>request(3,6000),\n  ()=>request(4,5000),\n  ()=>request(5,4000),\n]\n\nconst limitPromise = (arr,max)=>{\n  const pool = [];\n  const wait = [];\n\n  const run = (task)=>{\n    task().then(res=>{\n      const next = wait.shift();\n      console.log(res);\n      if(next) run(next);\n    })\n  }\n  for(let i =0;i<arr.length;i++){\n    const item = arr[i]\n    if(i<max){\n      run(item)\n    }else{\n      wait.push(arr[i]);\n    }\n  }\n}\n\nlimitPromise(arr,2);\n</code></pre>\n<ul>\n<li>手写promise重试（retry）</li>\n</ul>\n<pre><code class=\"language-js\">\n// 重试\nconst myPromiseRetry = (promise,times)=>{\n  return new Promise((resolve,reject)=>{\n    const fn = promise().then(res=>{\n      resolve(res);\n    }).catch(err=>{\n      if(times>0){\n        times--;\n        fn();\n      }else{\n        console.error('重试次数使用完毕');\n        reject(err);\n      }\n    })\n    fn();\n  })\n}\n</code></pre>\n<ul>\n<li>手写promise超时（timeout）</li>\n</ul>\n<pre><code class=\"language-js\">// 超时\nconst promiseTimeout = (promise,delay)=>{\n  return Promise.race([promise,new Promise(resolve=>{\n    setTimeout(()=>resolve(),delay)\n  })])\n}\n</code></pre>\n<ul>\n<li>用 Promise 封装一个 ajax</li>\n<li>按要求完成 mergePromise 代码</li>\n</ul>\n<pre><code class=\"language-js\">const timeout = (ms) =>\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve();\n    }, ms);\n  });\nconst ajax1 = () =>\n  timeout(2000).then(() => {\n    console.log(&quot;1&quot;);\n    return 1;\n  });\nconst ajax2 = () =>\n  timeout(1000).then(() => {\n    console.log(&quot;2&quot;);\n    return 2;\n  });\nconst ajax3 = () =>\n  timeout(2000).then(() => {\n    console.log(&quot;3&quot;);\n    return 3;\n  });\nconst mergePromise = (ajaxArray) => {\n  // 1,2,3 done [1,2,3] 此处写代码 请写出ES6、ES3 2中解法\n};\nmergePromise([ajax1, ajax2, ajax3]).then((data) => {\n  console.log(&quot;done&quot;);\n  console.log(data); // data 为[1,2,3]\n});\n// 执行结果为：1 2 3 done [1,2,3]\n</code></pre>\n"}}></div>
  }
  