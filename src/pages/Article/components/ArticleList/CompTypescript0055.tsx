
  import React,{useEffect} from 'react';
 
  import 'highlight.js/styles/xcode.css';
  const hljs = require('highlight.js');

  export default () => {
    useEffect(()=>{
      document.querySelectorAll('code').forEach(el => {
        el.style.backgroundColor='#f8f8f8';
        el.style.marginBottom='0.1rem';
        hljs.highlightElement(el);
      });
    },[])
    return <div style={{fontSize:'0.26rem'}} dangerouslySetInnerHTML={{__html:"<h1>Typescript面试题</h1>\n<ul>\n<li>在TypeScript中tsconfig.json有什么作用？</li>\n<li>在TypeScript中说说你对声明合并的理解</li>\n<li>在TypeScript中as语法是什么？</li>\n<li>在TypeScript中枚举和常量枚举有什么区别？</li>\n<li>在TypeScript中如何实现继承？</li>\n<li>如何将多个ts文件合并为一个js文件？</li>\n<li>在TypeScript支持静态类吗？为什么？</li>\n<li>在TypeScript中控制成员可见性有哪些方法？</li>\n<li>在TypeScript中如何创建对象？</li>\n<li>在TypeScript中如何定义和使用泛型？</li>\n<li>在TypeScript中如何创建和使用装饰器？</li>\n<li>什么是TypeScript接口？</li>\n<li>在TypeScript中如何与其他工具和库集成？</li>\n<li>在TypeScript中的lambda函数是什么？</li>\n<li>在Typescript中如何将字符串转换为数字？</li>\n<li>在TypeScript中如何访问模块外定义的类？</li>\n<li>在TypeScript中的getter/setter是什么？有什么作用？</li>\n<li>在TypeScript中支持哪些JSX模式？</li>\n<li>在TypeScript中如何让接口的所有属性都可选？</li>\n<li>在TypeScript中如何从子类调用基类构造函数？</li>\n<li>在TypeScript中有哪些三斜杠指令？</li>\n<li>在TypeScript中是如何检查null和undefined的？</li>\n<li>在TypeScript中如何创建变量？</li>\n<li>在TypeScript中解释下rest参数的作用及规则</li>\n<li>你是如何编译TypeScript的文件？</li>\n<li>请说说在TypeScript中什么是联合类型？</li>\n</ul>\n<pre><code>所谓“联合类型”其实就是多种类型的联合，也就是不仅仅一种类型。联合类型（Union Types）可以通过管道(|)给变量设置多种类型，赋值时可以根据设置的类型来赋值\n</code></pre>\n<ul>\n<li>请说说在TypeScript中什么是交叉类型？</li>\n</ul>\n<pre><code>所谓“交叉类型”通过&amp;符号将多个类型进行合并成一个类型\n原子类型进行合并是never，是没有意义的。例如number &amp; string，不可能有既满足字符串又满足数字类型。\n合并的接口类型中具有同名属性，如果同名的属性类型相同则合并之后还是原本的类型，如果不同合并之后为never。\n\n</code></pre>\n<ul>\n<li>在TypeScript中是如何实现函数重载的？</li>\n<li>在TypeScript中Omit类型有什么作用？</li>\n<li>在TypeScript中使用unknown的场景是什么？</li>\n<li>在TypeScript中什么是三斜线指令？</li>\n<li>在TypeScript中如何定义类？</li>\n<li>在TypeScript中的类与JavaScript类有什么不同？</li>\n<li>在TypeScript中怎样定义和使用命名空间？</li>\n<li>在TypeScript中是怎样进行类型检查的？</li>\n<li>在TypeScript中的void类型是什么？在什么场景下使用？</li>\n<li>在TypeScript中如何定义、导入和导出模块？</li>\n<li>在TypeScript中的null与undefined有什么区别？</li>\n<li>在TypeScript中如何支持类型推断？</li>\n<li>在TypeScript中any和unkown有什么区别？</li>\n<li>在TypeScript中装饰器有哪些应用场景？</li>\n<li>请说说你对TypeScript中装饰器的理解</li>\n<li>请说说你对TypeScript中mixin的理解</li>\n<li>请说说你对TypeScript中类的理解</li>\n<li>在TypeScript中never与void有什么区别？</li>\n<li>TypeScript有哪些内置数据类型？</li>\n<li>在TypeScript中interface与type有什么区别？</li>\n<li>请说说你对TypeScript中泛型的理解</li>\n<li>请说说你对TypeScript中模块的理解</li>\n<li>为什么要推荐使用TypeScript?</li>\n<li>请说说TypeScript有哪些特性？</li>\n<li>请说下TypeScript中的类型断言是什么？</li>\n<li>请说下在TypeScript中命名空间与模块的区别？</li>\n<li>TypeScript中支持的访问修饰符有哪些？</li>\n<li>请说说你对TypeScript中枚举的理解</li>\n<li>TypeScript中的Declare关键字有什么作用？</li>\n<li>你觉得TypeScript难吗？</li>\n<li>说说你对TypeScript的了解，它和JS有什么关系？</li>\n<li>你有在项目中使用过TypeScript吗？</li>\n<li>在TypeScript中泛型有什么作用？</li>\n<li>你是怎么优化你的 ts 代码的？</li>\n<li>你有用过哪些ts的高级类型？</li>\n<li>extends 和 implements 有什么区别？</li>\n<li>interface 和 type 到底有什么区别？</li>\n<li>Typescript 里有哪些 JavaScript 没有的类型？</li>\n</ul>\n<h3>TS笔试题</h3>\n<ol>\n<li>为什么会报错？如何解决</li>\n</ol>\n<pre><code>type User = {\n  id: number;\n  kind: string;\n};\n\nfunction makeCustomer<T extends User>(u: T): T {\n  // Error（TS 编译器版本：v4.4.2）\n  // Type '{ id: number; kind: string; }' is not assignable to type 'T'.\n  // '{ id: number; kind: string; }' is assignable to the constraint of type 'T', \n  // but 'T' could be instantiated with a different subtype of constraint 'User'.\n  return {\n    id: u.id,\n    kind: 'customer'\n  }\n}\n</code></pre>\n<p>参考</p>\n<pre><code>因为 T 只是约束与 User 类型，而不局限于User 类型，所以返回为T类型不仅仅只有 id和kind，So需要一个接收其他类型的变量\n解决方案：\n\ntype User = {\n  id: number;\n  kind: string;\n};\n\nfunction makeCustomer<T extends User>(u: T): T {\n  return {\n    ...u,\n    id: u.id,\n    kind: 'customer'\n  }\n}\n</code></pre>\n<ol start=\"2\">\n<li>我们希望参数 a 和 b 的类型都是一致的，即 a 和 b 同时为 number 或 string 类型。当它们的类型不一致的值，TS 类型检查器能自动提示对应的错误信息</li>\n</ol>\n<pre><code>function f(a: string | number, b: string | number) {\n  if (typeof a === 'string') {\n    return a + ':' + b; // no error but b can be number!\n  } else {\n    return a + b; // error as b can be number | string\n  }\n}\n\nf(2, 3); // Ok\nf(1, 'a'); // Error\nf('a', 2); // Error\nf('a', 'b') // Ok\n</code></pre>\n<p>参考</p>\n<pre><code>// 函数重载\nfunction f(a:number,b:number):number;\nfunction f(a:string,b:string):string;\n\nfunction f(a:number|string,b:number|string):number|string{\n    if(typeof a === 'string'){\n        return a+':'+b;\n    }else{\n        return (a as number) + (b as number);\n    }\n}\n</code></pre>\n<ol start=\"3\">\n<li>如何定义一个 SetOptional和SetRequired 工具类型，分别支持把给定的 keys 对应的属性变成可选的？和必填的。对应的使用示例如下所示：</li>\n</ol>\n<pre><code>type Foo = {\n\ta: number;\n\tb?: string;\n\tc: boolean;\n}\n\n// 测试用例\ntype SomeOptional = SetOptional<Foo, 'a' | 'b'>;\n\n// type SomeOptional = {\n// \ta?: number; // 该属性已变成可选的\n// \tb?: string; // 保持不变\n// \tc: boolean; \n// }\n\n// 测试用例\ntype SomeRequired = SetRequired<Foo, 'b' | 'c'>;\n// type SomeRequired = {\n// \ta: number;\n// \tb: string; // 该属性已变成必填\n// \tc: boolean; // 保持不变\n// }\n</code></pre>\n<h3>工具泛型的实现</h3>\n<pre><code class=\"language-ts\">// 实现Partial:将传入的属性变为可选项\ntype Partial<T>={ [P in keyof T]?:T[P] }\n// Required:将传入的属性变为必选项\ntype Required<T>={[P in keyof T]-?:T[P]}\n// Mutable:将 T 的所有属性的 readonly 移除\ntype Mutable<T>={-readonly [P in keyof T]:T[P]}\n//Readonly:将传入的属性变为只读选项\ntype Readonly<T>={readonly [P in keyof T]:T[P]}\n// Recorder:将 K 中所有的属性的值转化为 T 类型\ntype Recorder<K extends keyof any,T>={[P in K]:T}\n// Pick:从 T 中取出 一系列 K 的属性\ntype Pick<T,K extends keyof any>={[P in K]:T[P]}\n\n//Exclude: 条件语句\ntype Exclude<T,U>=T extends U ? never : T;\n// 例如， Exclude 的作用是从 T 中找出 U 中没有的元素, 换种更加贴近语义的说法其实就是从T 中排除 U\ntype T = Exclude<1|2,1|3> // 2\n\n// Extract的作用是提取出 T 包含在 U 中的元素, 换种更加贴近语义的说法就是从 T 中提取出 U\ntype Extract<T,U>=T extends U? T:never;\n\n// Omit: Pick 和 Exclude 进行组合, 实现忽略对象某些属性功能\ntype Omit<T,K>=Pick<T,Exclude<keyof T,K>>\n// 例如\ntype Foo = Omit<{name:string,age:number},'name'> // {age:number}\n\n// ReturnType:在条件类型语句中, 我们可以用 infer 声明一个类型变量并且对它进行使用,我们可以用它获取函数的返回类型\ntype ReturnType<T> = T extends(...args:any[])=>infer R?R:any;\n//infer R 就是声明一个变量来承载传入函数签名的返回值类型, 简单说就是用它取到函数返回值的类型方便之后使用.例如\nfunction foo(x:number):Array<number>{\n  return [x];\n}\ntype Foo = ReturnType<typeof foo>\n\n// AxiosReturnType:\n\n</code></pre>\n"}}></div>
  }
  