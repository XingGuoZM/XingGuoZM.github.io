
  import React,{useEffect} from 'react';
 
  import 'highlight.js/styles/xcode.css';
  const hljs = require('highlight.js');

  export default () => {
    useEffect(()=>{
      document.querySelectorAll('code').forEach(el => {
        el.style.backgroundColor='#f8f8f8';
        el.style.marginBottom='0.1rem';
        hljs.highlightElement(el);
      });
    },[])
    return <div style={{fontSize:'0.26rem'}} dangerouslySetInnerHTML={{__html:"<h1>原型链</h1>\n<h3>原型和原型链</h3>\n<ul>\n<li>prototype：引用TC39上的原话</li>\n</ul>\n<pre><code>object that provides shared properties for other objects\n\nWhen a constructor creates an object, that object implicitly references the constructor's &quot;prototype&quot; property for the purpose of resolving property references. The constructor's &quot;prototype&quot; property can be referenced by the program expression constructor.prototype, and properties added to an object's prototype are shared, through inheritance, by all objects sharing the prototype. Alternatively, a new object may be created with an explicitly specified prototype by using the Object.create built-in function.\n</code></pre>\n<p>上面大致意思就是prototype是一个给其他对象提供共享属性的对象，核心是<strong>属性共享</strong>。后面一大段的重点有以下几点</p>\n<ol>\n<li>prototype是挂在构造函数下的</li>\n<li>实例对象隐式引用构造函数的prototype（即object.__proto__===constructor.prototype）</li>\n<li>可以动态给实例对象的原型添加属性，并且会通过继承，传递给其他实例对象</li>\n<li>通过Object.create方法可以创建一个指定原型对象的对象</li>\n</ol>\n<p>prototype的作用是能让构造函数的属性在其创建的实例对象之间共享，而prototype也是个对象，原型链提供一条对象访问属性的路径</p>\n<ul>\n<li>__proto__\nmdn上说</li>\n</ul>\n<pre><code>Object 实例的__proto__访问器属性暴露了此对象的 [[Prototype]]（一个对象或 null）。\n</code></pre>\n<p>即__proto__可以访问或者设置对象的内部属性[[Prototype]]，对象的[[Prototype]]指向其构造函数的prototype，即我们可以简写成object._<em>proto</em>_ === constructor.prototype 或者 Object.getPrototypeOf(object) === constructor.prototype。这也是原型链的基础。</p>\n<p>因此我们可以说</p>\n<p>原型是构造函数和实例对象的连接的纽带，函数和对象的关系（横向），js中原型是继承的基础。每个对象（object）都有一个原型链对象（也叫隐式原型）__proto__（现在__proto__已经废弃，改为使用Object.getPrototypeOf()和Object.setPrototypeOf()来实现），所有构造函数都有一个原型对象prototype</p>\n<p>原型链：对象属性/方法的访问规则，它是顺着对象的隐式原型（__proto__）向上（构造函数）查找，父类和子类以及他们的实例对象之间的关联关系（垂直）。就像我们抽水的时候，水是顺着建好的水管来流动的，水管就是一个水的流动规则，可以向上流，也可以向下流，可以动态的构造水管的走向，自定义规则。原型链、作用域链等也是这样的，我们可以动态修改隐式原型，可以修改__proto__对象的某个属性，也可以重写__proto__对象，也可以通过对象隐式原型访问构造函数。</p>\n<p>原型和原型链组成了对象属性访问的规则网络（横向和纵向二维关系）</p>\n<h3>原型、隐式原型和构造函数(prototype、__proto__、constructor)</h3>\n<p>实例对象、构造函数，父类子类的关联关系总结如下公式</p>\n<pre><code>// 原型：描述了实例对象和构造函数的关联关系\n实例对象.constructor === 构造函数\n实例对象.__proto__ === 构造函数.prototype\n\n// 原型链：描述了构造函数和其祖先构造函数的关联关系\n子类.__proto__ === 父类\n子类.prototype.__proto__ === 父类.prototype\n</code></pre>\n<p>上面的公式等价于下面的例子</p>\n<pre><code class=\"language-js\">class A {}\nclass B extends A {}\n\nconst a = new A();\nconst b = new B();\n\n// a.constructor === A\n// a.__proto__ === A.prototype\n\n// B是一个对象\n// B.__proto__ === A\n// B是一个函数\n// B.prototype.__proto__ === A.prototype\n</code></pre>\n<h3>原型相关操作</h3>\n<ol>\n<li>创建一个指定原型对象的对象</li>\n</ol>\n<pre><code class=\"language-js\">/**\n *  Object.create(proto)即以现有对象（proto）作为原型创建一个新的对象。\n *  实现伪代码如下\n * \n * */\nfunction objectCreate(object){\n  const newObj = {}\n  newObj.__proto__ = object\n  return newObj\n}\n</code></pre>\n<pre><code class=\"language-js\">const p ={name:'jack'}\nconst p1 = Object.create(p)\nconsole.log(p1.name) // 'jack'\n</code></pre>\n<ol start=\"2\">\n<li>访问/设置对象的原型</li>\n</ol>\n<pre><code class=\"language-js\">// Object.getPrototypeOf()\nconst a = {}\nconst b = Object.create(a)\nconsole.log(Object.getPrototypeOf(b) === a) // true\n</code></pre>\n<pre><code class=\"language-js\">//Object.setPrototypeOf()\nconst a = {};\nconst b = {name:'jack'}\nObject.setPrototypeOf(a,b);\nconsole.log(a.name) // jack\n</code></pre>\n<pre><code class=\"language-js\">// __proto__(已废弃)\nconst a = {};\nconst b = {name:'jack'};\na.__proto__ = b;\nconsole.log(a.name) // jack\n</code></pre>\n<ol start=\"3\">\n<li>检测某个实例对象的原型链上是否存在构造函数的原型对象（prototype）。其实现伪代码如下</li>\n</ol>\n<pre><code class=\"language-js\">function myInstanceof(object,constructor){\n  left = object.__proto__\n  right = constructor.prototype\n  while(true){\n    if(left === null) return false\n    if(left === right) return true\n    left = left.__proto__\n  } \n}\n</code></pre>\n<pre><code class=\"language-js\">//判断一个对象是否存在于另一个对象的原型链中\n\n// Object.prototype.isPrototypeOf()\n</code></pre>\n<ol start=\"4\">\n<li>new的实现</li>\n</ol>\n<pre><code class=\"language-js\">/** \n * new关键词和Object.create()都会创建一个对象并返回一个对象，\n * new的过程概括起来有4步,实现伪代码如下\n */\nfunction myNew(constructor){\n  // 第1步，创建一个对象\n  object = {}\n  // 第2步，补齐原型链\n  object.__proto__ = constructor.prototype\n  // 第3步，确保执行上下文对象正确（this）\n  ret = constructor.call(object)\n  // 第4步，返回一个对象\n  return ret || object\n}\n</code></pre>\n<p>我们最常用的是通过字面量来创建对象，即const obj = {}这种方式等价于const obj = Object()</p>\n<ol start=\"5\">\n<li>怎么识别我的对象是通过哪种方式创建的呢？比如我们通过new来创建一个对象，就可以在构造函数中通过new.target来检测这个函数是否作为构造函数通过new来调用的，它指向直接被new执行的构造函数。例如</li>\n</ol>\n<pre><code class=\"language-js\">function Foo() {\n  if (!new.target) throw &quot;Foo() must be called with new&quot;;\n  console.log(&quot;Foo instantiated with new&quot;);\n  console.log(new.target)\n}\n\nFoo(); // throws &quot;Foo() must be called with new&quot;\nnew Foo(); // logs &quot;Foo instantiated with new&quot;\n</code></pre>\n<ol start=\"6\">\n<li>判断属性是是自有属性还是原型对象上的属性</li>\n</ol>\n<pre><code class=\"language-js\">// Object.prototype.hasOwnProperty()\n</code></pre>\n<ol start=\"7\">\n<li>实现继承</li>\n</ol>\n<pre><code class=\"language-js\">// 寄生组合式继承\nfunction extend(subClass, superClass) {\n  const F = function() {};\n  F.prototype = superClass.prototype;\n  subClass.prototype = new F(); \n  subClass.prototype.constructor = subClass;\n\n  subClass.superclass = superClass.prototype;\n  if(superClass.prototype.constructor == Object.prototype.constructor) {\n    superClass.prototype.constructor = superClass;\n  }\n}\n</code></pre>\n<h3>原型对象属性的操作</h3>\n<pre><code class=\"language-js\">function Fn1 (name) {\n  if (name) {\n    this.name = name;\n  }\n}\nFn1.prototype.name = &quot;jack&quot;\nlet a = new Fn1();\nconsole.log('a:', a.name);\n\nfunction Fn2 (name) {\n  this.name = name;\n}\nFn2.prototype.name = &quot;jack&quot;\nlet b = new Fn2();\nconsole.log('b:', b.name);\n</code></pre>\n<pre><code class=\"language-js\">function Foo () { }\nFoo.prototype.z = 3;\nvar obj = new Foo();\nconsole.info(obj.z)\nobj.z = 10;\nconsole.info(obj.z);\ndelete obj.z;\nconsole.info(obj.z);\n</code></pre>\n<pre><code class=\"language-js\">var tmp = {};\nvar A = function () { };\nA.prototype = tmp;\n\nvar a = new A();\nA.prototype = {};\n\nvar b = Object.create(tmp);\nb.constructor = A.constructor;\n\nconsole.log(a instanceof A);\nconsole.log(b instanceof A);\n</code></pre>\n<pre><code class=\"language-js\">function Person(age){\n  this.age = age;\n}\n\nPerson.prototype = {\n  constructor:Person,\n  getAge:function(){\n    console.log(this.age);\n  },\n }\n\nvar p = new Person(24);\nPerson.prototype.age = 18;\nObject.prototype.age = 20;\np.getAge();\n</code></pre>\n<h3>es6 class get/set</h3>\n<pre><code class=\"language-js\">class Phone{\n  constructor(price){\n    this.price = price;\n  }\n  get price(){\n    return 999;\n  }\n}\nvar p = new Phone(888);\nconsole.log(p.price);\n</code></pre>\n<h3>prototype和__proto__关系</h3>\n<pre><code class=\"language-js\">class A { }\nclass B extends A { }\nconst a = new A()\nconst b = new B()\n\nconsole.log(a.__proto__)\nconsole.log(b.__proto__)\nconsole.log(B.__proto__)\nconsole.log(B.prototype.__proto__)\nconsole.log(b.__proto__.__proto__)\n</code></pre>\n<h3>构造函数和普通函数</h3>\n<pre><code class=\"language-js\">var name = 'Jay'\nfunction Person (name) {\n  this.name = name;\n  console.log(this.name)\n}\nvar a = Person('Tom')\nconsole.log(name)\nconsole.log(a)\nvar b = new Person('Michael')\nconsole.log(b)\n</code></pre>\n<h3>Object.create()实现原理</h3>\n<pre><code class=\"language-js\">const Book = {\n  price: 32\n}\nconst book = Object.create(Book);\nbook.type = 'Math';\ndelete book.price;\ndelete book.type;\nconsole.log(book.price);\nconsole.log(book.type);\n</code></pre>\n<h3>原型链与闭包</h3>\n<pre><code class=\"language-js\">var Foo = (function () {\n  var x = 0;\n  function Foo () { }\n  Foo.prototype.increment = function () {\n    ++x;\n    console.log(x);\n  };\n  return Foo;\n})();\n\nvar a = new Foo();\na.increment();\na.increment();\nvar b = new Foo();\na.increment();\n</code></pre>\n"}}></div>
  }
  