
  import React,{useEffect} from 'react';
 
  import 'highlight.js/styles/xcode.css';
  const hljs = require('highlight.js');

  export default () => {
    useEffect(()=>{
      document.querySelectorAll('code').forEach(el => {
        el.style.backgroundColor='#f8f8f8';
        el.style.marginBottom='0.1rem';
        hljs.highlightElement(el);
      });
    },[])
    return <div style={{fontSize:'0.26rem'}} dangerouslySetInnerHTML={{__html:"<h1>作用域</h1>\n<h3>关键词</h3>\n<ul>\n<li>var、let/const、变量提升、暂时性死区</li>\n<li>词法作用域、执行上下文</li>\n<li>闭包</li>\n<li>函数、方法、IIFE、模块</li>\n</ul>\n<p>作用域是变量/常量的访问规则，或者说是变量/常量的影响范围，通过指定作用域的类型来分配变量的访问权限，例如函数作用域只在函数代码块内生效，全局作用域在全局任何地方都能访问。作用域类型即变量访问权限分配规则</p>\n<p>作用域链：在多层嵌套的父子作用域中，提供变量查找的渠道。</p>\n<h3>var变量提升</h3>\n<p>关键词：词法环境、块作用域、暂时死区</p>\n<p>变量的声明周期：创建、初始化、赋值、引用、销毁。变量提升相关的三个阶段是创建、初始化和赋值</p>\n<p>var变量提升：创建和初始化（undefined）是被提升的，赋值不是\nlet变量提升：创建是被提升的（存入暂时性死区），初始化和赋值不是\nfunction变量提升：创建、初始化和赋值同时被提升</p>\n<p>var定义变量特点</p>\n<ol>\n<li>变量提升：在任何时候都会在执行代码之前处理变量声明，var变量声明是编译时</li>\n<li>变量同名覆盖：var可以重复声明赋值，后面会覆盖前面</li>\n<li>全局使用var定义的变量会成为window的属性</li>\n<li>只认函数作用域和全局作用域</li>\n</ol>\n<p>块作用域\n词法环境：当执行代码块（{}包裹的代码）时会创建一个词法环境，与全局环境形成嵌套，词法环境里包含环境记录。而我们的let定义的变量就存放在这个词法环境中。let在多个块作用域中声明变量时，js会创建单独的区域由词法环境为这些变量维护一个类似栈的结构，所以同名的let变量在不同的代码块中声明是不会冲突的。即词法环境是执行上下文的另一个组件</p>\n<p>es6的let和const声明的变量在代码执行开始到声明之前，变量都处于暂时性死区（Temporal dead zone，TDZ）之中。暂时性死区是代码执行时，一段从当前作用域开始到使用let/const声明变量/常量行之前的区域，在这段区域中变量尚未被初始化，如果在这期间尝试访问变量将会抛出ReferenceError。例如</p>\n<pre><code class=\"language-js\">// TDZ，开始\nconsole.log(a);// undefined\nconsole.log(b);//RefernceError\nvar a = 1\nlet b = 2; // TDZ，结束(b)\n</code></pre>\n<p>let声明的变量将作用域限制在块作用域内，在代码没有执行到它的初始化语句之前，它仍然存在于TDZ中</p>\n<pre><code class=\"language-js\">function foo(){\n  var a = 1;\n  if(a){\n    let a = a + 1; // ReferenceError\n  }\n}\nfoo();\n</code></pre>\n<pre><code class=\"language-js\">function bar(n){\n  console.log(n); // {a:[1,2,3]}\n  for(let n of n.a){// ReferenceError\n    console.log(n);\n  }\n}\nbar({a: [1,2,3]})\n</code></pre>\n<p>let定义变量的特点</p>\n<ol>\n<li>存在暂时性死区，死区内访问变量会报错</li>\n<li>不能重复命名，存在重复命名会报错</li>\n<li>在块作用域中生效</li>\n</ol>\n<h3>函数作用域</h3>\n<p>创建函数有多种方式</p>\n<ol>\n<li>函数表达式</li>\n<li>function关键词</li>\n<li>箭头函数表达式（lamada函数）和自执行函数表达式（IIFE）</li>\n</ol>\n<p>函数作用域</p>\n<h3>模块</h3>\n<p>模块化的重要意义即拆分，作用域拆分，变量的影响</p>\n<h3>var 函数作用域/全局作用域</h3>\n<pre><code class=\"language-js\">if(! &quot;a&quot; in window){\n    var a = 1;\n}\nconsole.log(a);\n</code></pre>\n<pre><code class=\"language-js\">var a = 1;\nb = 2;\neval('var c = 3');\ndelete a;\ndelete b;\ndelete c;\n</code></pre>\n<h3>function</h3>\n<pre><code class=\"language-js\">(function f () {\n  function f () { return 1; }\n  return f();\n  function f () { return 2; }\n})();\n</code></pre>\n<pre><code class=\"language-js\">(function(x){\n  delete x;\n  return x;    \n}\n)(1);\n</code></pre>\n<h3>var与IIFE</h3>\n<pre><code class=\"language-js\">(function() {\n  var a = b = 5;\n})();   \nconsole.log(b);\nconsole.log(a);\n</code></pre>\n<pre><code class=\"language-js\">var a = 10;\n(function () {\n  console.log(a)\n  a = 5\n  console.log(window.a);\n  var a = 20;\n  console.log(a)\n})()\n</code></pre>\n<pre><code class=\"language-js\">var b = 10;\n(function b() {\n  b = 20;\n  console.log(b)\n})()\n</code></pre>\n<pre><code class=\"language-js\">var foo = &quot;Hello&quot;;\n(function () {\n  var bar = &quot; World&quot;;\n  console.log(foo + bar);\n})();\nconsole.log(foo + bar);\n</code></pre>\n<pre><code class=\"language-js\">// 输出结果\nvar name = 'Tom';\n(function () {\n  if (typeof name === 'undefined') {\n    var name = 'Jack';\n    console.log('Goodbye ' + name)\n  } else {\n    console.log('Hello ' + name);\n  }\n})();\n\n//输出结果\nvar name = 'Tom';\n(function () {\n  if (typeof name === 'undefined') {\n    name = 'Jack';\n    console.log('Goodbye ' + name)\n  } else {\n    console.log('Hello ' + name);\n  }\n})();\n\n</code></pre>\n<pre><code class=\"language-js\">var foo = {n:1};\n(function(foo){\n    console.log(foo.n);\n    foo.n = 3;\n    var foo = {n:2};\n    console.log(foo.n);\n})(foo);\nconsole.log(foo.n);\n</code></pre>\n<h3>变量覆盖</h3>\n<pre><code class=\"language-js\">meili()\nfunction meili () {\n  console.log(&quot;meili&quot;)\n}\nmogu()\nvar mogu = function () {\n  console.log(&quot;mogu&quot;)\n}\n</code></pre>\n<pre><code class=\"language-js\">compute(10, 100);\nvar compute = function (A, B) {\n  console.info(A * B);\n};\nfunction compute (A, B) {\n  console.info(A + B);\n}\nfunction compute (A, B) {\n  console.info((A + B) * 2);\n}\ncompute(2, 10);\n</code></pre>\n<pre><code class=\"language-js\">\ncheck('first');\nfunction check (ars) {\n  console.log(1, ars);\n}\n\ncheck('second');\nvar check = function (ars) {\n  console.log(2, ars);\n}\n</code></pre>\n<h3>异步操作中作用域</h3>\n<pre><code class=\"language-js\">// html\n<ul>\n  <li>1</li>\n  <li>2</li>\n  <li>3</li>\n  <li>4</li>\n</ul>\n// js\nvar elements = document.getElementsByTagName(&quot;li&quot;);\nfor (var i = 0; i < elements.length; i++) {\n  elements[i].onclick = function () {\n    console.log(i);\n  };\n}\n</code></pre>\n<pre><code class=\"language-js\">for (var i = 0; i < 3; i++) {\n  setTimeout(_ => {\n    console.log(i)\n  })\n}\n\nfor (let i = 0; i < 3; i++) {\n  setTimeout(_ => {\n    console.log(i)\n  })\n}\n</code></pre>\n<pre><code class=\"language-js\">for (var i = 0; i< 10; i++){\n   setTimeout(() => {\n    console.log(i);\n   }, 1000)\n}\n\nfor (var i = 0; i< 10; i++){\n  (function(i){\n    setTimeout(() => {\n    console.log(i);\n   }, 1000)\n  })(i)\n}\n\nfor (var i = 0; i< 10; i++){\n  (function(i){\n    setTimeout(() => {\n    console.log(i);\n   }, 1000*i)\n  })(i)\n}\n\nfor (var i = 0; i< 10; i++){\n  setTimeout(() => {\n    (function(i){console.log(i);}(i)\n  }), 1000)\n}\n\nfor (var i = 0; i< 10; i++){\n  setTimeout(() => {\n    console.log(i);\n  }, 1000)\n}\n</code></pre>\n"}}></div>
  }
  