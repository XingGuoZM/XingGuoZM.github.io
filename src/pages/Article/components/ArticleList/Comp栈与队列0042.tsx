
  import React,{useEffect} from 'react';
 
  import 'highlight.js/styles/xcode.css';
  const hljs = require('highlight.js');

  export default () => {
    useEffect(()=>{
      document.querySelectorAll('code').forEach(el => {
        el.style.backgroundColor='#f8f8f8';
        el.style.marginBottom='0.1rem';
        hljs.highlightElement(el);
      });
    },[])
    return <div style={{fontSize:'0.26rem'}} dangerouslySetInnerHTML={{__html:"<h3>栈和队列</h3>\n<hr>\n<ul>\n<li>使用栈实现队列</li>\n</ul>\n<pre><code class=\"language-js\">function Stack () {\n  this.data = [];\n  this.push = function (val) {\n    this.data.push(val);\n    return true;\n  }\n  this.pop = function () {\n    if (this.data.length === 0) return false;\n    return this.data.pop();\n  }\n}\n\n// 使用栈实现队列\nfunction FakeQueue () {\n  this.stack1 = new Stack();\n  this.stack2 = new Stack();\n  this.in = function (val) {\n    this.stack1.push(val);\n    return true;\n  }\n  this.out = function () {\n    while (true) {\n      const val = this.stack1.pop();\n      if (!val) break;\n      this.stack2.push(val);\n    }\n    return this.stack2.pop();\n  }\n}\n//测试\nconst fakeQ = new FakeQueue()\nfakeQ.in(1);\nfakeQ.in(2);\nfakeQ.in(3);\nfakeQ.in(4);\nconsole.log(fakeQ.out());\nconsole.log(fakeQ.out());\nconsole.log(fakeQ.out());\n\n</code></pre>\n<ul>\n<li>使用队列实现栈</li>\n</ul>\n<pre><code class=\"language-js\">\nfunction Queue () {\n  this.data = [];\n  this.in = function (val) {\n    this.data.push(val);\n    return true;\n  }\n  this.out = function () {\n    if (this.length() === 0) return false;\n    return this.data.shift();\n  }\n  this.length = function () {\n    return this.data.length;\n  }\n}\n// 使用队列实现栈\nfunction FakeStack () {\n  this.queue = new Queue();\n\n  this.push = function (val) {\n    this.queue.in(val)\n  }\n  this.pop = function () {\n    let n = this.queue.length();\n    if (n < 1) return false;\n    for (let i = 0; i < n - 1; i++) {\n      const val = this.queue.out();\n      this.queue.in(val);\n    }\n    return this.queue.out();\n  }\n}\n\nconst fakeS = new FakeStack()\nfakeS.push(1)\nfakeS.push(2)\nfakeS.push(3)\nfakeS.push(4)\nfakeS.push(5)\nconsole.log(fakeS.pop())\nconsole.log(fakeS.pop())\nconsole.log(fakeS.pop())\n</code></pre>\n<ul>\n<li>删除字符串中的所有相邻重复项，例如&quot;abbaca&quot;->&quot;ca&quot;</li>\n</ul>\n<pre><code class=\"language-js\">function removeDuplicates (str) {\n  const stack = [];\n  for (let i = 0; i < str.length; i++) {\n    if (stack.length > 0 &amp;&amp; stack[stack.length - 1] === str[i]) {\n      stack.pop();\n    } else {\n      stack.push(str[i]);\n    }\n  }\n  return stack.join('');\n}\n// 测试\nconst str = 'abbacd';\nconsole.log(removeDuplicates(str));\n</code></pre>\n<ul>\n<li>判断括号是否是匹配（“(){()[{}]} ()({}) {()}[]{()} [{{[()]}}]”）</li>\n</ul>\n<pre><code class=\"language-js\">const map = {\n  '(': ')',\n  '[': ']',\n  '{': '}'\n}\n\nconst isValid = (str) => {\n  const stack = [];\n\n  for (let i = 0; i < str.length; i++) {\n    const top = stack.length > 0 ? stack[stack.length - 1] : null\n    if (str[i] === ')' || str[i] === ']' || str[i] === '}') {\n      if (map[top] !== str[i]) {\n        return false;\n      } else {\n        stack.pop();\n      }\n    } else if (map[str[i]]) {\n      stack.push(str[i]);\n    }\n  }\n  return stack.length === 0;\n}\n\nconst str = '(){()[{}]} ()({}) {()}[]{()} [{{[()]}}]';\nconsole.log(isValid(str))\n</code></pre>\n<ul>\n<li>写一个方法判断大括号{}是否闭合</li>\n</ul>\n<pre><code class=\"language-js\">//方法一\nconst isValid = (str) => {\n  const stack = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '{') {\n      stack.push(str[i]);\n    } else if (str[i] === '}') {\n      stack.pop();\n    }\n  }\n  return stack.length === 0\n}\n//测试\nconst str = '{{addad{{aeesd}}}';\nconsole.log(isValid(str));\n</code></pre>\n<ul>\n<li>使用js实现一个循环队列</li>\n<li>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈</li>\n</ul>\n<pre><code class=\"language-js\">push(x);//将元素 x 推入栈中。\npop(); // 删除栈顶元素\ntop(); // 获取栈顶元素\ngetMin();// 检索栈中最小的元素\n\n// 示例\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   // --> 返回 -3\nminStack.pop();\nminStack.top();      // --> 返回 0\nminStack.getMin();   // --> 返回 -2\n</code></pre>\n<ul>\n<li>使用队列来实现击鼓传花</li>\n</ul>\n<pre><code>击鼓传花的规则:\n\n几个朋友一起玩一个游戏, 围成一圈, 开始数数（数数时数字都是挨着的，第一个人数1，之后的人数2）, 数到某个数字的人自动淘汰。汰的人后面再从1开始数，重复上面的游戏，直到就剩下一个人，请问剩下了谁？\n\n// 测试例子\nvar names = [&quot;John&quot;, &quot;Jack&quot;, &quot;Camila&quot;, &quot;Ingrid&quot;, &quot;Carl&quot;];\nvar endName = passGame(names, 8); // 数到 8 的人淘汰\nconsole.log(&quot;最终留下:&quot; + endName); // 'john'\n</code></pre>\n"}}></div>
  }
  