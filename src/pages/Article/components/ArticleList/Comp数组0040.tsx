
  import React,{useEffect} from 'react';
 
  import 'highlight.js/styles/xcode.css';
  const hljs = require('highlight.js');

  export default () => {
    useEffect(()=>{
      document.querySelectorAll('code').forEach(el => {
        el.style.backgroundColor='#f8f8f8';
        el.style.marginBottom='0.1rem';
        hljs.highlightElement(el);
      });
    },[])
    return <div style={{fontSize:'0.26rem'}} dangerouslySetInnerHTML={{__html:"<h3>数组</h3>\n<ul>\n<li>手写数组去重(deduplicate)的方法（支持多维数组）</li>\n</ul>\n<pre><code class=\"language-js\">// 去重\nconst deduplicate = (arr)=>{\n  return [...new Set(arr)];\n}\n</code></pre>\n<ul>\n<li>请通过reduce函数实现一维数组的求和</li>\n</ul>\n<pre><code class=\"language-js\">function sum (arr) {\n  return arr.reduce((val, cur) => val + cur);\n}\n\nconsole.log(sum([1, 5, 4, 3, 2]));\n</code></pre>\n<ul>\n<li>写个方法随机打乱一个数组</li>\n</ul>\n<pre><code class=\"language-js\">function getOutOfOrder (arr) {\n  const len = arr.length;\n  const indexMap = {};\n  const ans = [];\n  let index = 0;\n  while (true) {\n    index = Math.floor(Math.random() * len);\n    if (!indexMap[index]) {\n      indexMap[index] = true\n      ans.push(arr[index]);\n    }\n    if (ans.length === len) break;\n  }\n  return ans;\n}\n//测试\nconst arr = [1, 2, 3, 4, 5]\nconsole.log(getOutOfOrder(arr));\n</code></pre>\n<ul>\n<li>写一个获取数组的最大值、最小值的方法</li>\n</ul>\n<pre><code class=\"language-js\">// 方法一\nfunction getMaximum (intArr) {\n  const min = Math.min.apply(null, intArr);\n  const max = Math.max.apply(null, intArr);\n  return { min, max }\n}\n// 方法二\nfunction getMaximum (intArr) {\n  if (!intArr || intArr.length < 1) return false;\n  intArr = intArr.sort((a, b) => a - b);\n  return {\n    min: intArr[0],\n    max: intArr[intArr.length - 1]\n  }\n}\n// 测试\nconst arr = [1, 3, 4, 6, 8, 1, 3, 6, 99]\nconsole.log(getMaximum(arr))\n</code></pre>\n<ul>\n<li>如何快速让一个数组乱序，写出来</li>\n</ul>\n<pre><code class=\"language-js\">function getOutOrderArr (arr) {\n  const len = arr.length;\n  const map = {};\n  const ans = [];\n  while (ans.length < len) {\n    const key = Math.floor(Math.random() * len);\n    if (!map[key]) {\n      map[key] = true;\n      ans.push(arr[key]);\n    }\n  }\n  return ans;\n}\n// 测试\nconst arr = [1, 2, 2, 4, 5]\nconsole.log(getOutOrderArr(arr));\n</code></pre>\n<ul>\n<li>手写一个函数，数组转对象（二维数组，每一项都是一个仅有2项的字符串数组）</li>\n</ul>\n<pre><code class=\"language-js\">const array2Object = (arr) => {\n  return arr.reduce((pre, item) => {\n    pre[item[0]] = item[1];\n    return pre;\n  }, {});\n}\n// 测试\nconst arr = [\n  ['name', 'jack'],\n  ['age', '11'],\n  ['sex', '男']\n]\nconsole.log(array2Object(arr));\n</code></pre>\n<ul>\n<li>手写一个函数，数组转树（每一项带父级id：pid）</li>\n</ul>\n<pre><code class=\"language-js\">const arrayToTree = (arr,treeArr,pid)=>{\n  for(let node of arr){\n    if(node.pid === pid){\n      const newNode = {...node,children:[]};\n      treeArr.push(newNode);\n      arrayToTree(arr,newNode.children,node.id)\n    }\n  }\n}\n\nconst result = [];\narrayToTree(arr,result,null);\nconsole.log(result);\n</code></pre>\n<ul>\n<li>用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值</li>\n</ul>\n<pre><code class=\"language-js\">function getRandom (num) {\n  const set = new Set()\n\n  while (set.size < num) {\n    const num = Math.floor(Math.random() * 15 + 2)\n    set.add(num);\n  }\n  return [...set];\n}\n\nconsole.log(getRandom(5))\n</code></pre>\n<ul>\n<li>写一个方法判断数组内元素是否全部相同</li>\n</ul>\n<pre><code class=\"language-js\">function isEqualAll (arr) {\n  return arr.every(item => item === arr[0]);\n}\n\nconsole.log(isEqualAll([1, 1, 1, 1, 1, 1]))\n</code></pre>\n<ul>\n<li>写一个方法，判断给定的几个数字是否相等，如[1,1,1,1]相等</li>\n</ul>\n<pre><code class=\"language-js\">function isEqualAll (arr) {\n  return new Set(arr).size === 1;\n}\n\nconsole.log(isEqualAll([1, 1, 1, 1, 1, 1]))\n</code></pre>\n<ul>\n<li>写一个方法判断一组数字是连值，比如[1,2,3]，[9,0,1],这样的连值组合？连值是指12345678901234567890这样的数字相连的组合，像[1,2,3,4,5]是连值，但[1,3,4,5,6]不是，因为没有相连。</li>\n</ul>\n<pre><code class=\"language-js\">function isContinuousArr (arr) {\n  return arr.every((item, index) => index === 0 || item === (arr[index - 1] + 1) % 10)\n}\n\nconsole.log(isContinuousArr([9, 0, 1, 2, 3, 4]))\n\n</code></pre>\n<ul>\n<li>分别写一个方法实现基数排序、桶排序、归并排序、插入排序、交换排序、选择排序，并解释下时间复杂度和空间复杂度</li>\n</ul>\n<pre><code class=\"language-js\">// 快排，时间复杂度（nlogn ～ n^2）\nfunction quickSort (arr) {\n  if (arr.length === 0 || arr.length === 1) return arr;\n  const tmp = arr.shift();\n  const left = [];\n  const right = [];\n  for (const item of arr) {\n    if (item < tmp) {\n      left.push(item);\n    } else {\n      right.push(item);\n    }\n  }\n  return quickSort(left).concat(tmp, quickSort(right));\n}\n//插入排序\nfunction insertSort(arr) {\n  let temp;\n\n  for (let i = 1; i < arr.length; i++) {\n    temp = arr[i];\n    let j = i - 1;\n    while (j >= 0 &amp;&amp; temp < arr[j]) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n    arr[j + 1] = temp;\n  }\n  return arr;\n}\n</code></pre>\n<ul>\n<li>写一个洗扑克牌的方法</li>\n<li>用函数实现扑克牌排序</li>\n</ul>\n<pre><code class=\"language-js\">function initPoker () {\n  const list = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n  const types = ['♥️', '♠️', '♣️', '♦️']\n  const other = ['大王', '小王']\n  const size = 54;\n  function getPokerList () {\n    const ans = [];\n    list.forEach(item => ans.push(...types.map(ele => item + ele)))\n    return ans.concat(other);\n  }\n\n  function getRandomList () {\n    const set = new Set();\n    while (set.size < size) {\n      set.add(Math.floor(Math.random() * size));\n    }\n    return [...set];\n  }\n  return function refresh () {\n    const randomList = getRandomList();\n    const pokerList = getPokerList();\n    return randomList.map(item => pokerList[item]);\n  }\n}\n\nconst refresh = initPoker();\nconst ans = refresh();\nconsole.log(ans);\n</code></pre>\n<ul>\n<li>写一个方法，批量删除指定索引的数组元素</li>\n</ul>\n<pre><code class=\"language-js\">// filter\nfunction multiDel (arr, indexList) {\n  return arr.filter((_, index) => indexList.indexOf(index) === -1);\n}\n\nconsole.log(multiDel([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [2, 4, 6, 8]));\n</code></pre>\n<ul>\n<li>写一个数组去重的方法（支持多维数组）</li>\n</ul>\n<pre><code class=\"language-js\">function uniqueArr (arr) {\n  return [...new Set(arr.reduce(\n    (pre, cur) => {\n      return Array.isArray(cur) ? pre.concat(...uniqueArr(cur)) : pre.concat(cur);\n    }, [])\n  )]\n}\n\nconst arr = [\n  [1, 2], 1, [1, 2, [1, [2]]]\n]\nconsole.log(uniqueArr(arr));\n</code></pre>\n<ul>\n<li>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</li>\n</ul>\n<pre><code class=\"language-js\">function sum3 (arr) {\n  arr = arr.sort((a, b) => a - b);\n  let target = 0;\n  const ans = [];\n  for (let i = 0; i < arr.length; i++) {\n    let left = i + 1, right = arr.length - 1;\n    if (i > 0 &amp;&amp; arr[i] === arr[i - 1]) continue;\n    while (left < right) {\n      let sum = arr[i] + arr[left] + arr[right]\n      if (target === sum) {\n        ans.push([arr[i], arr[left], arr[right]]);\n        while (arr[left] === arr[left + 1]) left++;\n        while (arr[right] === arr[right - 1]) right--;\n        left++;\n        right--;\n      } else if (target > sum) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  return ans;\n}\n\nconsole.log(sum3([-1, 2, -1, 3, -2, -1]))\n</code></pre>\n<ul>\n<li>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。初始化nums1和nums2的数量分别为m和n，你可以假设nums1有足够的空间（空间大小大于等于m+n）来保存nums2中的元素，例如输入：nums1=[1,2,3,0,0,0],m=3,nums2=[2,5,6],n=3。输出：[1,2,2,3,5,6]</li>\n</ul>\n<pre><code class=\"language-js\">function merge2Nums (nums1, m, nums2, n) {\n  let index1 = 0, index2 = 0, index = 0;\n  const nums = [];\n  while (index1 < m &amp;&amp; index2 < n) {\n    if (nums1[index1] < nums2[index2]) {\n      nums[index++] = nums1[index1++];\n    } else {\n      nums[index++] = nums2[index2++];\n    }\n  }\n  while (index1 < m) {\n    nums[index++] = nums1[index1++];\n  }\n  while (index2 < n) {\n    nums[index++] = nums2[index2++];\n  }\n  return nums;\n}\n\nconsole.log(merge2Nums([1, 2, 3, 0, 0], 3, [2, 5, 6], 3));\n</code></pre>\n<ul>\n<li>写一个方法从数组中随机抽取N个不重复的元素</li>\n</ul>\n<pre><code class=\"language-js\">const getRandomN = function (arr, N) {\n  const set = new Set()\n  while (set.size < N) {\n    const index = Math.floor(Math.random() * arr.length)\n    set.add(arr[index]);\n  }\n  return [...set];\n}\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nconst N = 3;\nconsole.log(getRandomN(arr, N));\n</code></pre>\n<ul>\n<li>写一个方法找出指定一维数组所有不重复的元素和个数</li>\n</ul>\n<pre><code class=\"language-js\">const findOnly = function (arr) {\n  return arr.filter(item => arr.indexOf(item) === arr.lastIndexOf(item));\n}\nconst arr = [1, 2, 3, 2, 1, 1]\nconsole.log(findOnly(arr))\n</code></pre>\n<ul>\n<li>写一个方法，传入数字x，从一个一维数组里找到两个数字符合“n1 + n2 ＝ x”</li>\n</ul>\n<pre><code class=\"language-js\">const get2Num = (arr, x) => {\n\n  for (let i = 0; i < arr.length; i++) {\n    const index = arr.indexOf(x - arr[i])\n    if (index !== i &amp;&amp; index > -1) {\n      return [arr[i], arr[index]];\n    }\n  }\n  return false;\n}\nconst arr = [2, 1]\nconst x = 4;\nconsole.log(get2Num(arr, x))\n</code></pre>\n<ul>\n<li>写一个方法将一个数组中的元素，从前到后依次两两组合，最后一个与第一个组合</li>\n</ul>\n<pre><code class=\"language-js\">const buildPairs = function (arr) {\n  if (arr.length % 2 !== 0) return false;\n  const mid = arr.length / 2;\n  const pairs = [];\n  for (let i = 0; i < mid; i++) {\n    pairs.push([arr[i], arr[arr.length - i - 1]])\n  }\n  return pairs;\n}\n\nconst arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(buildPairs(arr))\n</code></pre>\n<ul>\n<li>使用js生成1-10000的数组</li>\n</ul>\n<pre><code class=\"language-js\">const array = Array.from({length: 10000}, (_, i) => i + 1);\n</code></pre>\n<ul>\n<li>从一个无序的整数数组中，找出最小和最大数之间缺失的数字，要求最小的时间复杂度</li>\n</ul>\n<pre><code class=\"language-js\">const findMissNumber = function (arr) {\n  const min = Math.min(...arr);\n  const max = Math.max(...arr);\n  const ans = new Array(max - min + 1).fill(0).map((_, index) => index + min);\n  arr.forEach(item => ans[item] = true);\n  return ans.filter(item => item !== true);\n}\nconst arr = [1, 5, 3, 8, 0];\nconsole.log(findMissNumber(arr))\n</code></pre>\n<ul>\n<li>写一个函数找出给定数组中的最大差值</li>\n</ul>\n<pre><code class=\"language-js\">const findMaxDecrease = arr => Math.max(...arr) - Math.min(...arr);\n</code></pre>\n<ul>\n<li>写一个方法判断在一个一维数组里，有且只有一个数等于给定的值</li>\n</ul>\n<pre><code class=\"language-js\">const findOnlyNum = (arr, v) => arr.filter(item => item === v).length === 1;\n</code></pre>\n<ul>\n<li>写一个方法检测指定的数组是否有重复的元素</li>\n</ul>\n<pre><code class=\"language-js\">const isRepeat = arr => new Set(arr).size !== arr.length;\n</code></pre>\n<ul>\n<li>数组元素全倒排列并去重</li>\n</ul>\n<pre><code class=\"language-js\">const removeRepeatAndSort = function (arr) {\n  return arr.sort((a, b) => b - a).reduce((pre, cur) => {\n    const len = pre.length;\n    if (len === 0) return [cur];\n    if (pre[len - 1] === cur) return pre\n    return pre.concat(cur);\n  }, [])\n}\n\nconst arr = [0, 9, 9, 8, 15, 88, 0]\nconsole.log(removeRepeatAndSort(arr))\n</code></pre>\n<ul>\n<li>写一个方法获取指定数组中间的值（一个或者两个）</li>\n</ul>\n<pre><code class=\"language-js\">const findArrayMiddle = function (arr) {\n\n  if (!Array.isArray(arr) || arr.length < 3) return arr;\n  const len = arr.length;\n  const isOdd = len % 2 === 0;\n  const index = Math.floor(len / 2);\n  return isOdd ? [arr[index - 1], arr[index]] : [arr[index]]\n}\nconst arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(findArrayMiddle(arr));\n</code></pre>\n<ul>\n<li>写一个方法把多维数组降维</li>\n</ul>\n<pre><code class=\"language-js\">const arr = [1, 2, [3, 4, [5, 6]]]\narr.flat(Infinity)\n</code></pre>\n<ul>\n<li>写一个方法js将数组对象中某个属性值相同的对象合并成一个新对象,例如</li>\n</ul>\n<pre><code>//输入\n\nlet data = [\n  { name: '住院医疗最高报销', tagName: '医疗', amount: '6000' },\n  { name: '身故赔付', tagName: '寿险', amount: '36.00' },\n  { name: '其他', tagName: '寿险', amount: '888.00' },\n  { name: '伤残赔付', tagName: '寿险', amount: '66.00' },\n  { name: '重疾赔付', tagName: '重疾', amount: '99.00' },\n]\n//输出\nlet resData = [\n  {\n    tagName: '医疗',\n    dataInfo: [\n      { name: '住院医疗最高报销', tagName: '医疗', amount: '6000' }\n    ]\n  }, {\n    tagName: '寿险',\n    dataInfo: [\n      { name: '身故赔付', tagName: '寿险', amount: '36.00' },\n      { name: '其他', tagName: '寿险', amount: '888.00' },\n      { name: '伤残赔付', tagName: '寿险', amount: '66.00' },\n    ]\n  }, {\n    tagName: '重疾',\n    dataInfo: [\n      { name: '重疾赔付', tagName: '重疾', amount: '99.00' },\n    ]\n  }\n]\n</code></pre>\n<pre><code class=\"language-js\">const mergeByTagName = function (arr) {\n  const result = {}\n\n  for (const item of arr) {\n    if (!result[item.tagName]) {\n      result[item.tagName] = { tagName: item.tagName, dataInfo: [] }\n    }\n    result[item.tagName].dataInfo.push(item);\n  }\n  return Object.values(result);\n}\n\nlet data = [\n  { name: '住院医疗最高报销', tagName: '医疗', amount: '6000' },\n  { name: '身故赔付', tagName: '寿险', amount: '36.00' },\n  { name: '其他', tagName: '寿险', amount: '888.00' },\n  { name: '伤残赔付', tagName: '寿险', amount: '66.00' },\n  { name: '重疾赔付', tagName: '重疾', amount: '99.00' },\n]\nconsole.log(mergeByTagName(data));\n</code></pre>\n<ul>\n<li>使用js写个方法，把下列数组对象按多字段排序，name升序，age降序</li>\n</ul>\n<pre><code>let listData = [\n  { name: &quot;张三&quot;, age: 38, num: 123 },\n  { name: &quot;李四&quot;, age: 15, num: 678 },\n  { name: &quot;王王&quot;, age: 16, num: 256 },\n  { name: &quot;老六&quot;, age: 28, num: 256 },\n  { name: &quot;老王&quot;, age: 16, num: 789 },\n  { name: &quot;大一&quot;, age: 23, num: 678 },\n  { name: &quot;大二&quot;, age: 20, num: 123 },\n  { name: &quot;大三&quot;, age: 40, num: 989 }\n];\n</code></pre>\n<pre><code class=\"language-js\">const sortName = listData.sort((a, b) =>\n  a.name[0].localeCompare(b.name[0], 'zh-CN')\n);\n\nconst listData2 = sortName.sort((a, b) => {\n  if (a.name == b.name) {\n    return b.age - a.age;\n  }\n  return;\n});\nconsole.log(listData2);\n</code></pre>\n<ul>\n<li>写一个算法找到数组中两个元素相加等于指定数的所有组合</li>\n</ul>\n<pre><code class=\"language-js\">const getTwoSum = function (arr, target) {\n  const res = [];\n\n  for (const item of arr) {\n    const a = item;\n    const b = target - a;\n    if (arr.indexOf(a) !== arr.indexOf(b) &amp;&amp; arr.indexOf(b) > -1) {\n      res.push([a, b])\n    }\n  }\n  return res;\n}\nconst arr = [1, 1, 2];\nconsole.log(getTwoSum(arr, 4))\n</code></pre>\n<ul>\n<li>写一个方法找到一维数组里，有且只有两个连续相等的所有元素</li>\n</ul>\n<pre><code class=\"language-js\">\n</code></pre>\n<ul>\n<li>写个方法近似计算指定数组或对象占用内存的大小</li>\n</ul>\n<pre><code class=\"language-js\">// 思路：遍历对象属性，对字符占用空间进行叠加，求出近似值\n</code></pre>\n<ul>\n<li>写个方法判断数组对象中是否存在某个对象</li>\n</ul>\n<pre><code class=\"language-js\">// 思路：给每一个对象分配一个id，相同的对象用同一个id，比较数组中对象 -> 比较数组对象的id属性\n</code></pre>\n"}}></div>
  }
  