
  import React,{useEffect} from 'react';
 
  import 'highlight.js/styles/xcode.css';
  const hljs = require('highlight.js');

  export default () => {
    useEffect(()=>{
      document.querySelectorAll('code').forEach(el => {
        el.style.backgroundColor='#f8f8f8';
        hljs.highlightElement(el);
      });
    },[])
    return <div style={{fontSize:'0.26rem'}} dangerouslySetInnerHTML={{__html:`<h3>网络模型、ISO/OSI七层模型、TCP/IP模型</h3>
<pre><code>最开始的时候网络协议是由网络公司自定义的，微软、苹果、思科等都有自己的网络协议，但这各家的协议是不能互联互通的。对于消费者来说这是技术垄断，买了苹果的设备就不能用微软的设备，因为他们的协议都是不一样的，没有统一的标准来规范网络协议，这极大阻碍了互联网的发展，因此国际标准化组织（ISO）制定了一个用于计算机或者通信系统间互联的标准体系，即开放式系统互联模型（OSI）。

这个标准解释了协议之间应该如何相互作用，OSI定义了网络互连的七层模型（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），TCP/IP是一组协议的代名词，它包括许多协议，组成了TCP/IP协议簇。它是把OSI七层模型简化成了四层模型（应用层、传输层、网络层、网络接口层），TCP/IP模型将OSI模型简化成4层，传输层和网络层被完整保留，因此网络中最核心的技术就是传输层和网络层技术。网络7层模型是一个参考标准，并非实现。网络4层模型是一个实现的应用模型

OSI模型是从上往下的，越底层越接近硬件，越上层越接近软件，这种分层模型是我们计算机科学中常用的方法，分层直接通过规定好的接口进行交互，每一层其实对它上一层或者下一层都是一个黑盒，其实他的上层和下层也不关心它的内部实现，只关心它们之间进行交互的接口，接口是规定的信息，要给到什么都是规定好的。传输层的数据称为段（segments），网络层的数据称为包（packages），数据链路层的数据称为帧（frames），物理层的数据称为比特流（bits）

这种分层模型的好处就是可以对任何一层进行独立升级和优化，只要保持接口不变那么这个模型整体就不会有问题。


应用层：为操作系统或网络应用程序提供网络服务的接口。起到了调用的作用，为应用软件而设的接口，设置与另一应用软件之间的通信，提供不同计算机间的文件传输、访问管理、电子邮件内容处理。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP、DNS等

表示层：主要任务是把所传输的数据的抽象语法变换为传送语法，把不同计算机内部的不同形式转换为网络通信中的标准形式。此外对传送数据的加密解密、正文压缩还原也属于表示层的的任务，即数据的处理，表示、安全、压缩等，格式有，jpeg、ascii、decoic、加密格式等。如URL加密、口令加密、图片编码解码等

会话层：负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。控制应用程序之间的会话能力，保持数据的单向传输，一对一，一对多的控制。如服务器验证用户登录、断点续传等

运输层：端到端传输数据的基本功能，高低层之间衔接的接口层，定义传输数据的协议端口号以及流控和差错校验，如TCP、UDP、进程、端口

网络层：定义ip编址，定义路由功能，进行逻辑地址的寻址，实现不同网络之间路径选择，如不同设备的数据转发。如IP地址、路由器、多层交换机、防火墙等

数据链路层(DataLink)：定义数据的传输格式，如何传输，如何标识。建立逻辑连接、进行硬件地址寻址、差错校验等，将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。如MAC地址、网卡、网桥、二层交换机等

物理层（Physical）：底层数据传输，建立、维护、断开物理连接。如中继器、集线器、网线等
</code></pre>
<h3>传输层</h3>
<p>TCP是面向连接的、可靠的、基于字节流的传输层协议。</p>
<p>TCP协议主要特点</p>
<pre><code>TCP是面向连接的传输层协议。应用程序在使用TCP协议之前，必须先建立TCP连接，在传输数据完毕之后，必须释放已经建立的TCP连接

每一条TCP连接只能有两个端点，每一个TCP连接只能是点对点的（一对一）。

TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据，TCP连接的两端都设有发送缓存和接收缓存，用来存放双向通信的数据。

字节流。用户消息通过TCP协议传输时，消息可能被操作系统分组成多个TCP报文，如果接收方的程序不知道消息边界，是无法读出一个有效的用户消息的。并且TCP报文是有序的，当前一个TCP报文没有收到的时候，即使它先收到的后面的TCP报文，那么也不能扔给应用层去处理，同时对重复的TCP报文会自动丢弃。

可靠性：无论网络链路中出现了怎样的变化，TCP都可以保证一个报文一定可以到达接收端。通过流量控制、超时重传、拥塞控制等机制来保证可靠性
</code></pre>
<p>TCP连接的三次握手和四次挥手</p>
<ol>
<li>最开始，客户端和服务端都处于CLOSE状态，首先服务器主动监听某个端口，处理LISTEN状态</li>
<li>客户端向服务端发起连接，并且把第一个SYN报文发送给服务端，之后客户端处于SYN-SEND状态</li>
<li>服务端收到客户端的SYN报文，向客户端发送SYN+ACK报文，之后服务端处于SYN-RCVD状态</li>
<li>客户端收到服务端的报文后，还要向服务端发送一个应答报文ACK，之后客户端处于ESTABLISH状态</li>
<li>服务端收到客户端的应答报文之后，也处于ESTABLISH状态</li>
</ol>
<p><strong>第三次握手是可以携带数据的，前两次是不可以携带数据的</strong></p>
<h4>为什么是三次握手，而不是两次、四次</h4>
<pre><code>阻止重复历史连接的初始化，防止旧的重复连接初始化造成混乱，即为了防止已经失效的连接请求报文段突然又传到服务端，产生错误
TCP的可靠连接是靠seq（sequence numbers序列号）来达成的，通过TCP连接发送的每一个包，都有一个sequence number，因为每个包都要序列号的，所以都能被确认收到这些包，即通信双方都要确认对方收到了自己的序列号

同步双方的初始序列号
避免浪费资源
</code></pre>
<h4>第一次握手丢失了，会发生什么？</h4>
<p>会触发「超时重传」机制，重传 SYN 报文，而且重传的 SYN 报文的序列号都是一样的，不同版本的操作系统可能超时时间不同，有的1s、有的3s，这个时间是写死在内核里的。在Linux里，客户端的 SYN 报文最大重传次数由 tcp_syn_retries内核参数控制，这个参数是可以自定义的，默认值一般是 5。通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，每次超时的时间是上一次的 2 倍。当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。</p>
<h4>第二次握手丢失了，会发生什么？</h4>
<p>服务端收到客户端第一次握手后，就会回SYN-ACK给客户端，这就是第二次握手，此时服务端就会进入到SYN-RCVD状态
第二次握手的SYN-ACK有两个作用</p>
<ul>
<li>第二次握手里的ACK，是对第一次握手的确认报文</li>
<li>第二次握手里的SYN，是服务端发起建立TCP连接的报文</li>
</ul>
<p>因为第二次握手报文里包含对客户端第一次握手的确认ACK报文，如果客户端迟迟收不到第二次握手，那么客户端就会觉得自己的SYN报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重新传输SYN报文。最终客户端断开连接</p>
<p>又因为第二次握手中包含服务端SYN报文，当客户端收到后，需要给服务端发送ACK确认报文（第三次握手），服务端才会认为该SYN报文被客户端收到了，如果第二次握手丢失了，那么服务端收不到第三次握手，于是服务端这边会触发超时重传机制，重新传输SYN-ACK报文。最终服务端断开连接</p>
<h4>第三次握手丢失了，会发生什么？</h4>
<p>第三次握手是对第二次握手的SYN的确认报文，当第三次握手丢失了，服务端迟迟收不到确认报文，就会触发超时重传机制，重新传输SYN-ACK直到收到第三次握手或者达到最大重传次数。ACK报文是不会有重传的，当ACK丢失了，就有对方重传对应的报文。</p>
<h4>SYN攻击</h4>
<p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的半连接队列，使得服务端不能为正常用户服务</p>
<p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务</p>
<h4>TCP和UDP的区别</h4>
<pre><code>连接： TCP面向连接的传输层协议，传输数据之前先要建立连接。UDP不需要连接，即刻传输数据

服务对象：TCP提供一对一的两点服务。UDP支持一对一、一对多、多对多的交互通信。

可靠性：TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。UDP尽最大努力交付，不保证可靠交付数据，但可以基于UDP传输协议实现一个可靠的传输协议，例如QUIC协议

拥塞机制、流量控制：TCP有拥塞机制和流量控制机制，保证数据传输的安全性。UDP则没有，即使网络非常拥堵，也不会影响UDP的发送速率

首部开销：TCP首部较长会有一定的开销，没有开启选项时为20个字节，开启之后会更长。UDP首部固定8字节，固定不变，开销较小

传输方式：TCP是流式传输，没有边界，但保证顺序和可靠。UDP是一个包一个包的发送，是有边界的，但可能丢包或乱序。

分片不同：TCP数据大小如果大于MSS大小，则会在传输层进行分片，目标主机收到后，同样在传输层组装TCP数据包，如果中途丢失一个分片，只需要传输丢失的这个分片。UDP的大小如果大于MTU的大小，则会在IP层进行分片，目标主机收到后，在IP层组装完数据，再接着传输给传输层。
</code></pre>
<h4>TCP和UDP的应用场景</h4>
<pre><code>TCP：FTP文件传输、HTTP/HTTPS
UDP：包总量较少的通信，如DNS、SNMP等、视频音频等多媒体通信、广播通信。
</code></pre>
<h3>网络层</h3>
<p>网络层的作用就是实现主机和主机之间的通信</p>
<p>IP地址是用来识别网络上的设备，IP地址是由网络地址与主机地址两部分所组成。例如，在我们家里常用的地址：192.168.1.2中，192.168.1为网络地址。主机地址位于IP地址的后段，用来标识具体设备。同一网络上的设备都具有唯一的IP地址，只有IP地址唯一才能正常通信。就拿刚才的电话号码来说，只有号码唯一才能真正找到人，在IP地址192.168.1.2中，2就是主机地址。</p>
<p>IP地址按照网络类型划分为5类：分别是A、B、C、D、E</p>
<p>子网掩码即掩盖掉主机号，将子网掩码和 IP 地址按位计算 AND，就可得到网络号。
子网掩码除了划分网络号和主机号，还一个作用即划分子网</p>
<h3>网关和路由器</h3>
<p><a href="https://datatracker.ietf.org/doc/html/rfc2616">rfc草案</a></p>
<p><a href="https://juejin.cn/post/6844903492763533319">网络七层模型与四层模型区别</a></p>
<p><a href="https://xiaolincoding.com/network/">小林coding</a></p>
`}}></div>
  }
  