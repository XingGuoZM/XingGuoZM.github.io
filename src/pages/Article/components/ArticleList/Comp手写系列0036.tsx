
  import React,{useEffect} from 'react';
 
  import 'highlight.js/styles/xcode.css';
  const hljs = require('highlight.js');

  export default () => {
    useEffect(()=>{
      document.querySelectorAll('code').forEach(el => {
        el.style.backgroundColor='#f8f8f8';
        el.style.marginBottom='0.1rem';
        hljs.highlightElement(el);
      });
    },[])
    return <div style={{fontSize:'0.26rem'}} dangerouslySetInnerHTML={{__html:"<ul>\n<li>手写instanceof</li>\n</ul>\n<pre><code class=\"language-js\">// 引用类型判断\nconst myInstanceof = (object,constructor)=>{\n  let prototype = constructor.prototype;\n  object = object.__proto__;\n  while(true){\n    if(!object) return false;\n    if(prototype == object) return true;\n    object = object.__proto__;\n  }\n}\n</code></pre>\n<ul>\n<li>手写let、const</li>\n</ul>\n<pre><code class=\"language-js\">/**\n * 块级作用域下有效\n * 不能重复声明\n * 不能预处理，不存在变量提升，即未声明之前的代码不能调用\n */\n  (function(){\n    var i = 0;\n    console.log(i)\n  })()\n\n  //const\n/**\n * @param {*} key \n * @param {*} value \n * 用于声明一个常量\n * 块级作用域有效\n * 不能重复声明\n * 不能预处理，不存在变量提升，未声明之前不能调用\n * 不能修改\n * 声明时必须初始化\n */\nfunction myConst(key,value){\n  window[key]=value;\n  Object.defineProperty(window,key,{\n    enumerable:false,\n    configurable:false,\n    get:function(){\n      return value;\n    },\n    set:function(newValue){\n      if(newValue!==value){\n        throw TypeError('这是只读变量，不可修改')\n      }else{\n        return value;\n      }\n    }\n  })\n}\n</code></pre>\n<ul>\n<li>手写一个new方法</li>\n</ul>\n<pre><code class=\"language-js\">// 实现一：\nconst myNew = (fn,...args)=>{\n  const obj = {};\n  // 补齐原型链\n  obj.__proto__ = fn.prototype;\n  // 补齐this指向\n  const ret = fn.call(obj,...args);\n  return typeof ret === 'object' ? ret:obj;\n}\n\n// 实现二：\nfunction myNew2(){\n\n  const Constructor = [].shift.call(arguments);\n  const obj = Object.create(Constructor.prototype);\n  const ret = Constructor.apply(obj,arguments);\n  return typeof ret === 'object' ? ret:obj;\n}\n</code></pre>\n<ul>\n<li>手写一个call、bind的方法</li>\n</ul>\n<pre><code class=\"language-js\">/*\n* 思路：在指定的上下文对象里添加一个属性（目标函数）并执行\n* 1. 确保ctx一定是一个对象\n  2. 确保添加key的唯一性\n*/\nFunction.prototype.myCall = function(ctx,...args){\n  ctx = (ctx === undefined || ctx === null) ? globalThis : Object(ctx);\n  var key = Symbol();\n  var fn = this;\n  Object.defineProperty(ctx,key,{\n    enumerable:false,\n    value:fn,\n  })\n  var ret = ctx[key](...args);\n  delete ctx[key];\n  return ret;\n}\n/*\n*思路：将this与指定上下文对象绑定，返回一个函数\n1. 参数合并\n2. 判断bind之后的函数是不是构造函数\n*/\nFunction.prototype.myBind = function (ctx) {\n  ctx = (ctx === null || ctx === undefined) ? globalThis : Object(ctx);\n  var args = Array.prototype.slice.call(arguments, 1);\n  var fn = this;\n  return function func () {\n    var nextArgs = Array.prototype.slice.call(arguments);\n    var allArgs = args.concat(nextArgs);\n    if (Object.getPrototypeOf(this) === func.prototype) {\n      var obj = { };\n      Object.setPrototypeOf(obj, fn.prototype);\n      fn.apply(obj, allArgs);\n      return obj;\n    }\n    return fn.apply(ctx, allArgs);\n  }\n}\n\n</code></pre>\n<ul>\n<li>实现setTimeout、setInterval</li>\n</ul>\n<pre><code class=\"language-js\">const mySetInterval=(cb,delay)=>{\n  const context =this;\n  const timer = setTimeout(()=>{\n    cb.call(context);\n    clearTimeout(timer);\n    mySetInterval(cb,delay)\n  },delay);\n}\n</code></pre>\n<ul>\n<li>\n<p>实现一个寄生式组合继承</p>\n</li>\n<li>\n<p>手写数组拉平方法(flat)</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">// 方法一\nconst flat = (arr,ans)=>{\n  for(const item of arr){\n    if(Array.isArray(item)){\n      flat(item,ans)\n    }else{\n      ans.push(item);\n    }\n  }\n  return ans;\n}\n// 方法二\nconst flat2 = (arr)=>{\n  return String(arr).split(',').map(Number);\n}\n</code></pre>\n<ul>\n<li>手写数组indexOf</li>\n</ul>\n<pre><code class=\"language-js\">const myIndexOf = (arr, item) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === item) return i;\n  }\n  return -1;\n}\n</code></pre>\n<ul>\n<li>手写数组reduce</li>\n</ul>\n<pre><code class=\"language-js\">\nconst myReduce = (array, callback, initialValue) => {\n  const fakeArray = [...array]\n  if (initialValue) {\n    fakeArray.unshift(initialValue);\n  }\n  let preValue = fakeArray[0];\n  for (let i = 0; i < fakeArray.length - 1; i++) {\n    preValue = callback(preValue, fakeArray[i + 1]);\n  }\n  console.log(preValue);\n  return preValue;\n}\n</code></pre>\n<ul>\n<li>用reduce实现map方法</li>\n</ul>\n<pre><code class=\"language-js\">const mapFromReduce = (array, callback) => {\n  return array.reduce((value, currValue, currIndex, array) => {\n    value.push(callback(currValue, currIndex, array));\n    return value;\n  }, []);\n}\n</code></pre>\n<ul>\n<li>手写数组排序方法(sort)</li>\n</ul>\n<pre><code class=\"language-js\">// 快速排序\nconst quickSort = (arr)=>{\n  const left =[];\n  const right =[];\n  const flag = arr.splice(0,1);\n  for(let i=0;i<arr.length;i++){\n    if(flag<arr[i]){\n      right.push(arr[i]);\n    }else{\n      left.push(arr[i]);\n    }\n  }\n  return quickSort(left).concat(flag,quickSort(right));\n}\n</code></pre>\n<ul>\n<li>用js实现typeof的功能</li>\n<li>请实现一个 JSON.stringfy</li>\n<li>请实现一个 JSON.parse</li>\n<li>原生实现 ES5 的 Object.create()方法</li>\n</ul>\n"}}></div>
  }
  