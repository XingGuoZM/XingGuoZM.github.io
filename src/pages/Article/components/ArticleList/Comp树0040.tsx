
  import React,{useEffect} from 'react';
 
  import 'highlight.js/styles/xcode.css';
  const hljs = require('highlight.js');

  export default () => {
    useEffect(()=>{
      document.querySelectorAll('code').forEach(el => {
        el.style.backgroundColor='#f8f8f8';
        el.style.marginBottom='0.1rem';
        hljs.highlightElement(el);
      });
    },[])
    return <div style={{fontSize:'0.26rem'}} dangerouslySetInnerHTML={{__html:"<h2>树</h2>\n<ul>\n<li>使用js创建二叉树</li>\n</ul>\n<pre><code class=\"language-js\">// 创建二叉树\nfunction TreeNode(val,left=null,right=null){\n  this.left=left || null;\n  this.right=right || null;\n  this.val = val;\n}\n//     1\n//  2    3\n//4  5  6  7\nfunction buildTree(){\n  const root = new TreeNode(1);\n  root.left = new TreeNode(2);\n  root.right = new TreeNode(3);\n  root.left.left = new TreeNode(4);\n  root.left.right = new TreeNode(5);\n  root.right.left = new TreeNode(6);\n  root.right.right = new TreeNode(7);\n  return root;\n}\n</code></pre>\n<ul>\n<li>手写树先序、中序、后序、层序遍历（递归+迭代）</li>\n</ul>\n<pre><code class=\"language-js\">// 先序遍历\nfunction traverse(root,ret){\n    if(!root) return ;\n    ret.push(root.val);\n    traverse(root.left,ret);\n    traverse(root.right,ret);\n}\n// 测试\nconst root = buildTree();\nconst ret = [];\ntraverse(root,ret);\nconsole.log(ret) // [1, 2, 4, 5, 3, 6, 7]\n</code></pre>\n<pre><code class=\"language-js\">//层序遍历\nfunction traverse(root,ret,index){\n    if(!root) return ;\n    ret[index] = ret[index] || [];\n    ret[index].push(root.val);\n    index++;\n    traverse(root.left,ret,index);\n    traverse(root.right,ret,index);\n}\n// 测试\nconst root = buildTree();\nconst ret = [];\ntraverse(root,ret,0);\nconsole.log(ret) //[ [1],[2, 3] , [4, 5, 6, 7]]\n</code></pre>\n<pre><code class=\"language-js\">// 先序\nfunction traverse(root,ret){\n    let stack=[];\n\n    while(root){\n        ret.push(root.val);\n        stack.push(root);\n        root=root.left;\n    }\n    \n    while(stack.length>0){\n        const node = stack.pop();\n        let t = node.right\n        while(t){\n            ret.push(t.val)\n            stack.push(t)\n            t=t.left;\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"language-js\">// 层序\nfunction traverse(root,ret,index){\n    let stack=[];\n    let preNode;\n    while(root){\n        stack.push(root);\n        root=root.left;\n        index++;\n    }\n    \n    while(stack.length>0){\n        const node = stack[stack.length-1];\n        if(!node.left &amp;&amp; !node.right ||\n           preNode === node.right ||\n           preNode === node.left &amp;&amp; !node.right\n          ){\n                index--;\n                ret[index] = ret[index] || [];\n                ret[index].push(node.val);\n                preNode=node;\n                stack.pop();\n          }else{\n           let t = node.right;\n            while(t){\n                stack.push(t);\n                t=t.left;\n                index++;\n            } \n          }\n    }\n}\n</code></pre>\n<ul>\n<li>判断平衡二叉树、搜索二叉树、完全二叉树</li>\n</ul>\n<ul>\n<li>写一个方法，实现树的路径查询</li>\n<li>根据元素ID遍历树形结构，查找到所有父元素ID</li>\n<li>写一个方法将origin转化为tree，要求支持无限级和性能</li>\n<li>使用原生js实现给定节点的父节点下所有子节点的元素</li>\n<li>遍历一个树结构，除了可以用递归外还能用哪些方法？</li>\n</ul>\n"}}></div>
  }
  